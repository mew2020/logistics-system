import { ref, onUnmounted, watch, provide, defineComponent, getCurrentInstance, computed, onMounted, openBlock, createElementBlock, unref, Fragment, createElementVNode, normalizeStyle, renderSlot, toDisplayString, createCommentVNode, inject, onBeforeUnmount, mergeProps, onUpdated, warn as warn$1, nextTick, watchEffect, watchPostEffect } from 'vue';

function mitt(n){return {all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e]);},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]));},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e);}),(i=n.get("*"))&&i.slice().map(function(n){n(t,e);});}}}

const mittInstance = mitt();
function usePubSub() {
    return mittInstance;
}

// eslint-disable-next-line @typescript-eslint/no-empty-function
const noop = () => { };

const BMapScriptLoaderWrapper = {};
function getScriptAsync({ key, src, addCalToWindow = false, exportGetter = noop }) {
    const exported = exportGetter();
    if (!BMapScriptLoaderWrapper[key] && !exported) {
        BMapScriptLoaderWrapper[key] = new Promise((resolve, reject) => {
            const script = document.createElement('script');
            const cal = () => {
                resolve(exportGetter());
                window.document.body.removeChild(script);
            };
            if (addCalToWindow) {
                window[key] = cal;
            }
            else {
                script.onload = function () {
                    if (!this.readyState || this.readyState == 'loaded' || this.readyState == 'complete') {
                        script.onload = null;
                        cal();
                    }
                };
            }
            script.src = src;
            script.type = 'text/javascript';
            script.defer = true;
            script.onerror = reject;
            document.body.appendChild(script);
        });
    }
    else if (exported !== undefined) {
        return Promise.resolve(exported);
    }
    return BMapScriptLoaderWrapper[key];
}

/** @format */
const DEFAULT_PLUGINS_SOURCE_LINK = {
    TrackAnimation: '//mapopen.bj.bcebos.com/github/BMapGLLib/TrackAnimation/src/TrackAnimation.min.js',
    Mapvgl: 'https://unpkg.com/mapvgl/dist/mapvgl.min.js',
    MapvglThreeLayers: 'https://unpkg.com/mapvgl/dist/mapvgl.threelayers.min.js',
    Mapv: 'https://unpkg.com/mapv/build/mapv.min.js',
    MapvThree: 'https://unpkg.com/mapv-three/dist/mapvthree.umd.js'
};
const pluginLoaderMap = {
    TrackAnimation: (customSourceLink) => getScriptAsync({
        src: customSourceLink || DEFAULT_PLUGINS_SOURCE_LINK['TrackAnimation'],
        addCalToWindow: false,
        key: 'trackAnimation'
    }),
    Mapvgl: (customSourceLink) => getScriptAsync({
        src: customSourceLink || DEFAULT_PLUGINS_SOURCE_LINK['Mapvgl'],
        addCalToWindow: false,
        key: 'Mapvgl'
    }),
    MapvglThreeLayers: (customSourceLink) => getScriptAsync({
        src: customSourceLink || DEFAULT_PLUGINS_SOURCE_LINK['MapvglThreeLayers'],
        addCalToWindow: false,
        key: 'MapvglThreeLayers'
    }),
    Mapv: (customSourceLink) => getScriptAsync({
        src: customSourceLink || DEFAULT_PLUGINS_SOURCE_LINK['Mapv'],
        addCalToWindow: false,
        key: 'Mapv'
    }),
    MapvThree: (customSourceLink) => getScriptAsync({
        src: customSourceLink || DEFAULT_PLUGINS_SOURCE_LINK['MapvThree'],
        addCalToWindow: false,
        key: 'MapvThree'
    })
};
function initPlugins(plugins, customPluginSourceLink = {}) {
    // 都处理成 () => promise
    const pluginsLoaders = [...new Set(plugins)].reduce((pluginsLoaderArr, pluginsKey) => {
        let plugin;
        if (typeof pluginsKey === 'string' && (plugin = pluginLoaderMap[pluginsKey])) {
            pluginsLoaderArr.push(plugin(customPluginSourceLink[pluginsKey]));
        }
        else if (typeof pluginsKey === 'function') {
            pluginsLoaderArr.push(pluginsKey());
        }
        return pluginsLoaderArr;
    }, []);
    // 加载插件
    return Promise.all(pluginsLoaders);
}

function bindEvents(props, VueEmit, instance) {
    for (const key of Object.keys(props)) {
        if (/^on/.test(key) && props[key]) {
            const _key = key.replace(/^on/, '').toLocaleLowerCase();
            instance.addEventListener(_key, (e) => {
                var _a, _b;
                e.preventDefault = e.preventDefault || ((_a = e.domEvent) === null || _a === void 0 ? void 0 : _a.preventDefault.bind(e.domEvent));
                e.stopPropagation = e.stopPropagation || ((_b = e.domEvent) === null || _b === void 0 ? void 0 : _b.stopPropagation.bind(e.domEvent));
                VueEmit(_key, e);
            });
        }
    }
}

const warnedMessages = new Set();
/**
 * warn 抛出警告
 * @internal
 * @param {string} 警告内容
 */
function warn(location, message) {
    console.warn(`[Vue3 BaiduMap GL/${location}]: ${message}`);
}
function error(location, message) {
    console.error(`[Vue3 BaiduMap GL/${location}]: ${message}`);
}
function warnOnce(location, message) {
    const mergedMessage = `[Vue3 BaiduMap GL/${location}]: ${message}`;
    if (warnedMessages.has(mergedMessage))
        return;
    warnedMessages.add(mergedMessage);
    console.error(mergedMessage);
}

const isClient = typeof window !== 'undefined';
const isDef = (val) => typeof val !== 'undefined';
/**
 *
 * @param value 判断是否是字符串的值
 * @returns
 */
function isString(value) {
    return Object.prototype.toString.call(value) === '[object String]';
}
/**
 *
 * @param value 判断是否是字符串的值
 * @returns
 */
function isArray(value) {
    return Object.prototype.toString.call(value) === '[object Array]';
}

var DistrictType;
(function (DistrictType) {
    DistrictType[DistrictType["PROVINCE"] = 0] = "PROVINCE";
    DistrictType[DistrictType["CITY"] = 1] = "CITY";
    DistrictType[DistrictType["AREA"] = 2] = "AREA";
})(DistrictType || (DistrictType = {}));

/**
 * 点对象转地图点实例
 */
function pathPointsToMapPoints(pathPoints) {
    return pathPoints.map(({ lng, lat }) => new BMapGL.Point(lng, lat));
}
function getPoint$1({ lng, lat }) {
    return new BMapGL.Point(lng, lat);
}

let id = 0;
function getUid() {
    return `${id++}`;
}

function proxyValue(target, key, defaultValue, callback) {
    Object.defineProperty(target, key, {
        get() {
            return defaultValue;
        },
        set(value) {
            defaultValue = value;
            callback && callback(defaultValue);
        }
    });
}

function conditionalCall(conditionalFlagGetter, trulyCall, falselyCall) {
    return (arg) => (conditionalFlagGetter() ? trulyCall(arg) : falselyCall(arg));
}

/**
 * watch 回调辅助前置判断
 * @param cal watch 处理函数
 * @returns (nv: T, ov: T) => void
 */
function callWhenDifferentValue(cal) {
    return (nv, ov) => {
        if (nv === ov || (nv !== ov && JSON.stringify(nv) !== JSON.stringify(ov)))
            cal(nv);
    };
}

/**
 * 获取地图区域边界
 * @param cal 获取成功后的回调函数
 * @returns { isLoading, boundaries, get }
 */
function useAreaBoundary(cal) {
    const isLoading = ref(false);
    const boundaries = ref([]);
    let boundaryInstance;
    const getFn = (area) => {
        if (!boundaryInstance) {
            boundaryInstance = new BMapGL.Boundary();
        }
        isLoading.value = true;
        boundaryInstance.get(area, (rs) => {
            isLoading.value = false;
            boundaries.value = rs.boundaries;
            cal && cal(boundaries);
        });
    };
    onUnmounted(() => (boundaryInstance = null));
    return {
        /**
         * 是否加载中
         */
        isLoading,
        /**
         * 区域边界数据
         */
        boundaries,
        /**
         * 获取指定区域边界
         * @param {string} area 区域名
         * @example get('北京市')
         */
        get: getFn
    };
}

const statusMap$1 = {
    1: 'PLAYING',
    2: 'INITIAL',
    3: 'STOPPING'
};
/**
 * 轨迹动画
 * @param {any} map 地图组件实例引用
 * @param {UseTrackAnimationOptions} options 轨迹动画配置
 * @returns { setPath, start, stop}
 */
function useTrackAnimation(map, options) {
    let instance;
    let pl;
    let mapComponentInstance;
    let mapInstance;
    const status = ref('INITIAL');
    const _options = options || {};
    let prevStartTimeStamp = undefined;
    watch(() => map.value, (n) => {
        mapComponentInstance = n;
    });
    const init = () => {
        if (!instance) {
            mapInstance = mapComponentInstance.getMapInstance();
            instance = new BMapGLLib.TrackAnimation(mapInstance, pl, _options);
            proxyValue(instance, '_status', instance._status, syncState);
        }
    };
    const setPath = (path) => {
        const point = path.map((pathItem) => new BMapGL.Point(pathItem.lng, pathItem.lat));
        pl = new BMapGL.Polyline(point);
        init();
    };
    const start = () => {
        const now = performance.now();
        const _prevStartTimeStamp = prevStartTimeStamp || 0;
        const _delay = _options.delay || 0;
        if (instance && now - _prevStartTimeStamp > _delay && status.value === 'INITIAL') {
            instance.start();
        }
        prevStartTimeStamp = performance.now();
    };
    const cancel = () => {
        if (instance) {
            instance.cancel();
        }
    };
    const stop = () => {
        if (instance) {
            instance.pause();
        }
    };
    const proceed = () => {
        if (instance) {
            instance.continue();
        }
    };
    const syncState = () => {
        if (instance) {
            status.value = statusMap$1[instance._status];
        }
    };
    onUnmounted(() => {
        if (instance && status.value !== 'INITIAL') {
            instance.cancel();
        }
        // 手动回收内存
        if (mapInstance) {
            mapInstance.removeOverlay(pl);
            pl = null;
        }
    });
    return {
        /**
         * 设置路径动画路径
         */
        setPath,
        /**
         * 开始动画
         */
        start,
        /**
         * 暂停动画
         */
        stop,
        /**
         * 取消动画
         */
        cancel,
        /**
         * 继续播放动画
         */
        proceed,
        /**
         * 动画状态
         */
        status
    };
}

/**
 * 获取一个地图经纬度点实例
 */
function usePoint() {
    const point = ref(null);
    const genPoint = ({ lng, lat }) => {
        point.value = new BMapGL.Point(lng, lat);
    };
    return {
        /**
         * BMapGL.Point 实例
         */
        point,
        /**
         * 设置实例点坐标
         */
        set: genPoint
    };
}

// FIXME: 取消动画后再次开始动画, 地图上 pio 不消失, 可能是地图本身 bug
function useViewAnimation(map, options) {
    options = options || {};
    options.disableDragging = options.disableDragging !== undefined ? false : true;
    const status = ref('INITIAL');
    // 保存未初始化前的事件监听
    const eventListener = {
        animationcancel: [() => (status.value = 'INITIAL')],
        animationend: [() => (status.value = 'INITIAL')],
        animationstart: [() => (status.value = 'PLAYING')]
    };
    let mapComponentInstance;
    let mapInstance;
    let initd = false;
    watch(() => map.value, (n) => {
        mapComponentInstance = n;
    });
    const syncDragging = () => {
        const { enableDragging } = mapComponentInstance.getBaseMapOptions();
        mapComponentInstance.setDragging(enableDragging);
    };
    const defaultValue = {
        addEventListener(event, cal) {
            if (!eventListener[event]) {
                eventListener[event] = [];
            }
            eventListener[event].push(cal);
        },
        removeEventListener(event, cal) {
            const subs = eventListener[event];
            if (subs) {
                if (!cal) {
                    eventListener[event] = [];
                }
                else {
                    for (let i = subs.length; i >= 0; i--) {
                        if (subs[i] === cal) {
                            subs.splice(i, 1);
                        }
                    }
                }
            }
        }
    };
    let viewAnimation = defaultValue;
    const createViewAnimation = (keyFrames) => {
        const { loop, duration, delay } = options;
        for (const keyFrame of keyFrames) {
            if (keyFrame.center) {
                const { lng, lat } = keyFrame.center;
                keyFrame.center = new BMapGL.Point(lng, lat);
            }
        }
        viewAnimation = new BMapGL.ViewAnimation(keyFrames, {
            duration,
            delay,
            interation: loop
        });
        for (const eventKey of Object.keys(eventListener)) {
            const events = eventListener[eventKey];
            if (events && events.length) {
                events.forEach((cal) => {
                    viewAnimation.addEventListener(eventKey, cal);
                });
            }
        }
        initd = true;
    };
    const start = () => {
        if (initd && status.value !== 'PLAYING') {
            mapInstance = mapComponentInstance.getMapInstance();
            mapInstance.startViewAnimation(viewAnimation);
            mapComponentInstance.setDragging(!options.disableDragging);
        }
    };
    const cancel = () => {
        if (initd && status.value !== 'INITIAL') {
            viewAnimation._cancel(mapInstance);
            syncDragging();
        }
    };
    const stop = () => {
        if (initd && status.value === 'PLAYING') {
            viewAnimation._pause();
            status.value = 'STOPPING';
        }
    };
    const proceed = () => {
        if (initd && status.value === 'STOPPING') {
            viewAnimation._continue();
            status.value = 'PLAYING';
        }
    };
    onUnmounted(() => {
        try {
            if (viewAnimation && status.value == 'INITIAL') {
                mapInstance = mapComponentInstance.getMapInstance();
                viewAnimation._cancel(mapInstance);
                syncDragging();
            }
        }
        catch (e) {
            return false;
        }
    });
    return {
        viewAnimation,
        start,
        cancel,
        stop,
        proceed,
        status,
        setKeyFrames: createViewAnimation
    };
}

/**
 * ip定位
 */
function useIpLocation(cal) {
    const location = ref({});
    const isLoading = ref(true);
    const init = () => {
        isLoading.value = true;
        new BMapGL.LocalCity().get((res) => {
            isLoading.value = false;
            location.value = {
                code: res.code,
                point: res.center,
                name: res.name
            };
            cal && cal(location);
        });
    };
    return {
        location,
        isLoading,
        get: init
    };
}

const statusMap = {
    // 定位成功
    0: 'BMAP_STATUS_SUCCESS',
    // 定位超时
    8: 'ERR_POSITION_TIMEOUT',
    // 定位不可用
    2: 'ERR_POSITION_UNAVAILABLE',
    // 没有权限，定位被拒绝
    6: 'ERR_PERMISSION_DENIED'
};
function useBrowserLocation(options, cal) {
    options = options || {};
    const location = ref({});
    const isLoading = ref(true);
    const isError = ref(false);
    const status = ref();
    const init = () => {
        options.SDKLocation = options.enableSDKLocation;
        new Promise((resolve, reject) => {
            isLoading.value = true;
            const geolocation = new BMapGL.Geolocation();
            geolocation.getCurrentPosition(function (res) {
                const _status = geolocation.getStatus();
                status.value = statusMap[_status];
                if (_status === window['BMAP_STATUS_SUCCESS']) {
                    const { address, accuracy, point } = res;
                    resolve({
                        accuracy,
                        point,
                        address
                    });
                }
                else {
                    reject();
                }
            }, options);
        })
            .then((res) => {
            isError.value = false;
            location.value = res;
            cal && cal(location);
        })
            .catch(() => {
            isError.value = true;
        })
            .finally(() => {
            isLoading.value = false;
        });
    };
    return {
        get: init,
        isLoading,
        isError,
        status,
        location
    };
}

/**
 * 由地址解析坐标点
 */
function useAddressGeocoder(cal) {
    const point = ref();
    const isLoading = ref(true);
    const isEmpty = ref(true);
    let geocoder;
    const init = () => {
        if (!geocoder) {
            geocoder = new BMapGL.Geocoder();
        }
    };
    const get = (address, city) => {
        init();
        if (!address)
            return error('useAddressGeocoder', 'missing required params: address');
        if (!city)
            return error('useAddressGeocoder', 'missing required  params: city');
        const isBatch = isArray(address);
        isLoading.value = true;
        (() => {
            if (isBatch) {
                return Promise.all(address.map((item) => getPoint(geocoder, item, city)));
            }
            return getPoint(geocoder, address, city);
        })()
            .then((res) => {
            if (res) {
                if (isBatch) {
                    let emptyCount = 0;
                    point.value = res.map((item) => {
                        emptyCount += +!item;
                        return item;
                    });
                    isEmpty.value = emptyCount === res.length;
                }
                else {
                    point.value = res;
                    isEmpty.value = false;
                }
            }
            else {
                point.value = res;
                isEmpty.value = true;
            }
            cal && cal(point);
        })
            .catch((err) => {
            error('useAddressGeocoder', err.message);
            isEmpty.value = true;
            point.value = null;
        })
            .finally(() => {
            isLoading.value = false;
        });
    };
    return {
        get,
        point,
        isLoading,
        isEmpty
    };
}
function getPoint(geocoder, address, city) {
    return new Promise((resolve) => {
        geocoder.getPoint(address, (point) => resolve(point ? point : null), city);
    });
}

/**
 * 由地址解析坐标点
 */
function usePointGeocoder(options, cal) {
    options = options || {};
    const result = ref();
    const isLoading = ref(true);
    const isEmpty = ref(true);
    let geocoder;
    const init = (point) => {
        if (!point)
            return error('usePointGeocoder', 'missing required params: point');
        if (!geocoder) {
            geocoder = new BMapGL.Geocoder();
        }
        const isBatch = isArray(point);
        isLoading.value = true;
        (() => {
            if (isBatch) {
                return Promise.all(point.map((item) => getAddress(geocoder, item, options)));
            }
            return getAddress(geocoder, point, options);
        })()
            .then((res) => {
            if (res) {
                if (isBatch) {
                    let emptyCount = 0;
                    result.value = res.map((item) => {
                        emptyCount += +!item;
                        return item;
                    });
                    isEmpty.value = emptyCount === res.length;
                }
                else {
                    result.value = res;
                    isEmpty.value = false;
                }
            }
            else {
                result.value = res;
                isEmpty.value = true;
            }
            cal && cal(result);
        })
            .catch(() => {
            isEmpty.value = true;
            result.value = undefined;
        })
            .finally(() => {
            isLoading.value = false;
        });
    };
    return {
        get: init,
        result,
        isLoading,
        isEmpty
    };
}
function getAddress(geocoder, point, options) {
    return new Promise((resolve) => {
        geocoder.getLocation(new BMapGL.Point(point.lng, point.lat), (res) => {
            if (res)
                resolve(res);
            else
                resolve(null);
        }, options);
    });
}

var CoordinatesFromType;
(function (CoordinatesFromType) {
    /**
     *  WGS84坐标（GPS标准坐标）
     */
    CoordinatesFromType[CoordinatesFromType["COORDINATES_WGS84"] = 1] = "COORDINATES_WGS84";
    /**
     *  WGS84的平面墨卡托坐标（搜狗地图坐标）
     */
    CoordinatesFromType[CoordinatesFromType["COORDINATES_WGS84_MC"] = 2] = "COORDINATES_WGS84_MC";
    /**
     * GCJ02坐标(火星坐标)，即高德地图、腾讯地图、谷歌坐标和MapABC等地图使用的坐标；
     */
    CoordinatesFromType[CoordinatesFromType["COORDINATES_GCJ02"] = 3] = "COORDINATES_GCJ02";
    /**
     *  GCJ02的平面墨卡托坐标（火星坐标对应的墨卡托平面坐标）
     */
    CoordinatesFromType[CoordinatesFromType["COORDINATES_GCJ02_MC"] = 4] = "COORDINATES_GCJ02_MC";
    /**
     *  百度地图采用的经纬度坐标（bd09ll）
     */
    CoordinatesFromType[CoordinatesFromType["COORDINATES_BD09"] = 5] = "COORDINATES_BD09";
    /**
     * 百度地图采用的墨卡托平面坐标（bd09mc）
     */
    CoordinatesFromType[CoordinatesFromType["COORDINATES_BD09_MC"] = 6] = "COORDINATES_BD09_MC";
    /**
     * 图吧地图坐标
     */
    CoordinatesFromType[CoordinatesFromType["COORDINATES_MAPBAR"] = 7] = "COORDINATES_MAPBAR";
    /**
     * 51地图坐标
     */
    CoordinatesFromType[CoordinatesFromType["COORDINATES_51"] = 8] = "COORDINATES_51";
})(CoordinatesFromType || (CoordinatesFromType = {}));
var CoordinatesToType;
(function (CoordinatesToType) {
    /**
     * GCJ02坐标(火星坐标)，即高德地图、腾讯地图、谷歌坐标和MapABC等地图使用的坐标；
     */
    CoordinatesToType[CoordinatesToType["COORDINATES_GCJ02"] = 3] = "COORDINATES_GCJ02";
    /**
     * 百度地图采用的经纬度坐标（bd09ll）
     */
    CoordinatesToType[CoordinatesToType["COORDINATES_BD09"] = 5] = "COORDINATES_BD09";
    /**
     * 百度地图采用的墨卡托平面坐标（bd09mc）
     */
    CoordinatesToType[CoordinatesToType["COORDINATES_BD09_MC"] = 6] = "COORDINATES_BD09_MC";
})(CoordinatesToType || (CoordinatesToType = {}));
function usePointConvertor() {
    const result = ref();
    const isLoading = ref(true);
    const isError = ref(false);
    const status = ref();
    let convertor;
    const init = (points, from, to) => {
        if (!points)
            return error('usePointConvertor', 'missing required params: points');
        if (!from)
            return error('usePointConvertor', 'missing required params: from');
        if (!to)
            return error('usePointConvertor', 'missing required params: to');
        if (!points.length)
            return;
        if (!convertor) {
            convertor = new BMapGL.Convertor();
        }
        isLoading.value = true;
        const pointsInstance = points.map((item) => new BMapGL.Point(item.lng, item.lat));
        getConvertor(convertor, pointsInstance, from, to)
            .then((res) => {
            result.value = res.points.map((item) => ({ lng: item.lng, lat: item.lat }));
            status.value = res.status;
            isError.value = false;
        })
            .catch((status) => {
            status.value = status;
            isError.value = true;
        })
            .finally(() => {
            isLoading.value = false;
        });
    };
    return {
        convert: init,
        result,
        isLoading,
        isError,
        status
    };
}
function getConvertor(convertor, point, from, to) {
    return new Promise((resolve, reject) => {
        convertor.translate(point, from, to, (res) => {
            if (res.status === 0)
                resolve(res);
            else
                reject(res.status);
        });
    });
}

let icons = null;
function useDefaultMarkerIcons() {
    if (icons !== null)
        return icons;
    const defaultIconUrl = '//mapopen.bj.bcebos.com/cms/react-bmap/markers_new2x_fbb9e99.png';
    icons = {
        simple_red: new BMapGL.Icon(defaultIconUrl, new BMapGL.Size(42 / 2, 66 / 2), {
            imageOffset: new BMapGL.Size(454 / 2, 378 / 2),
            imageSize: new BMapGL.Size(600 / 2, 600 / 2)
        }),
        simple_blue: new BMapGL.Icon(defaultIconUrl, new BMapGL.Size(42 / 2, 66 / 2), {
            imageOffset: new BMapGL.Size(454 / 2, 450 / 2),
            imageSize: new BMapGL.Size(600 / 2, 600 / 2)
        }),
        loc_red: new BMapGL.Icon(defaultIconUrl, new BMapGL.Size(46 / 2, 70 / 2), {
            imageOffset: new BMapGL.Size(400 / 2, 378 / 2),
            imageSize: new BMapGL.Size(600 / 2, 600 / 2)
        }),
        loc_blue: new BMapGL.Icon(defaultIconUrl, new BMapGL.Size(46 / 2, 70 / 2), {
            imageOffset: new BMapGL.Size(400 / 2, 450 / 2),
            imageSize: new BMapGL.Size(600 / 2, 600 / 2)
        }),
        start: new BMapGL.Icon(defaultIconUrl, new BMapGL.Size(50 / 2, 80 / 2), {
            imageOffset: new BMapGL.Size(400 / 2, 278 / 2),
            imageSize: new BMapGL.Size(600 / 2, 600 / 2)
        }),
        end: new BMapGL.Icon(defaultIconUrl, new BMapGL.Size(50 / 2, 80 / 2), {
            imageOffset: new BMapGL.Size(450 / 2, 278 / 2),
            imageSize: new BMapGL.Size(600 / 2, 600 / 2)
        }),
        location: new BMapGL.Icon(defaultIconUrl, new BMapGL.Size(28 / 2, 40 / 2), {
            imageOffset: new BMapGL.Size(248 / 2, 466 / 2),
            imageSize: new BMapGL.Size(600 / 2, 600 / 2)
        })
    };
    for (let i = 1; i <= 10; i++) {
        icons['red' + i] = new BMapGL.Icon(defaultIconUrl, new BMapGL.Size(42 / 2, 66 / 2), {
            imageOffset: new BMapGL.Size((42 / 2) * (i - 1), 0),
            imageSize: new BMapGL.Size(600 / 2, 600 / 2)
        });
    }
    for (let i = 1; i <= 10; i++) {
        icons['blue' + i] = new BMapGL.Icon(defaultIconUrl, new BMapGL.Size(42 / 2, 66 / 2), {
            imageOffset: new BMapGL.Size((42 / 2) * (i - 1), 132 / 2),
            imageSize: new BMapGL.Size(600 / 2, 600 / 2)
        });
    }
    return icons;
}

function useInstanceId() {
    const instanceId = getUid();
    provide('parentComponentId', instanceId);
    return instanceId;
}

const _hoisted_1$3 = ["id"];
var script$n = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BMap'
}, { __name: 'index', props: {
        ak: {},
        apiUrl: {},
        width: { default: '100%' },
        height: { default: '550px' },
        center: { default: () => ({ lat: 39.915185, lng: 116.403901 }) },
        mapType: { default: 'BMAP_NORMAL_MAP' },
        zoom: { default: 14 },
        heading: { default: 0 },
        tilt: { default: 0 },
        minZoom: { default: 0 },
        maxZoom: { default: 21 },
        noAnimation: { type: Boolean, default: false },
        mapStyleId: {},
        mapStyleJson: {},
        showControls: { type: Boolean, default: false },
        plugins: {},
        pluginsSourceLink: {},
        displayOptions: {},
        restrictCenter: { type: Boolean, default: true },
        enableTraffic: { type: Boolean, default: false },
        enableDragging: { type: Boolean, default: true },
        enableInertialDragging: { type: Boolean, default: true },
        enableScrollWheelZoom: { type: Boolean, default: false },
        enableContinuousZoom: { type: Boolean, default: true },
        enableResizeOnCenter: { type: Boolean, default: true },
        enableDoubleClickZoom: { type: Boolean, default: false },
        enableKeyboard: { type: Boolean, default: true },
        enablePinchToZoom: { type: Boolean, default: true },
        enableAutoResize: { type: Boolean, default: true },
        enableIconClick: { type: Boolean },
        loadingBgColor: { default: '#f1f1f1' },
        loadingTextColor: { default: '#999' },
        backgroundColor: { default: () => [245, 245, 245, 100] },
        onClick: {},
        onDblclick: {},
        onRightclick: {},
        onRightdblclick: {},
        onMaptypechange: {},
        onMousemove: {},
        onMouseover: {},
        onMouseout: {},
        onMovestart: {},
        onMoving: {},
        onMoveend: {},
        onZoomstart: {},
        onZoomend: {},
        onAddoverlay: {},
        onAddcontrol: {},
        onRemovecontrol: {},
        onRemoveoverlay: {},
        onClearoverlays: {},
        onDragstart: {},
        onDragging: {},
        onDragend: {},
        onAddtilelayer: {},
        onRemovetilelayer: {},
        onLoad: {},
        onResize: {},
        onHotspotclick: {},
        onHotspotover: {},
        onHotspotout: {},
        onTilesloaded: {},
        onTouchstart: {},
        onTouchmove: {},
        onTouchend: {},
        onLongpress: {}
    }, emits: [
        'initd',
        'unload',
        'pluginReady',
        'click',
        'dblclick',
        'rightclick',
        'rightdblclick',
        'maptypechange',
        'mousemove',
        'mouseover',
        'mouseout',
        'movestart',
        'moving',
        'moveend',
        'zoomstart',
        'zoomend',
        'addoverlay',
        'addcontrol',
        'removecontrol',
        'removeoverlay',
        'clearoverlays',
        'dragstart',
        'dragging',
        'dragend',
        'addtilelayer',
        'removetilelayer',
        'load',
        'resize',
        'hotspotclick',
        'hotspotover',
        'hotspotout',
        'tilesloaded',
        'touchstart',
        'touchmove',
        'touchend',
        'longpress'
    ], setup(__props, { expose: __expose, emit: vueEmits }) {
        const props = __props;
        const mapContainer = ref();
        let map = null;
        // 是否初始化
        let initd = ref(false);
        const instance = getCurrentInstance();
        const instanceId = useInstanceId();
        // 地图初始化的发布
        const { emit } = usePubSub();
        const width = computed(() => (isString(props.width) ? props.width : `${props.width}px`));
        const height = computed(() => (isString(props.height) ? props.height : `${props.height}px`));
        const shouldRender = isClient && !!instance;
        // 初始化地图
        function init() {
            if (!shouldRender)
                return;
            const { proxy } = instance;
            const ak = props.ak || (proxy && proxy.$baiduMapAk);
            const apiUrl = props.apiUrl || (proxy && proxy.$baiduMapApiUrl);
            if (process.env.NODE_ENV !== 'production') {
                if (!ak && !apiUrl) {
                    return warn('BMap', 'ak or apiUrl is required');
                }
            }
            const plugins = props.plugins && proxy.$baiduMapPlugins
                ? Object.assign(proxy.$baiduMapPlugins, props.plugins)
                : props.plugins || proxy.$baiduMapPlugins;
            const pluginsSourceLink = props.pluginsSourceLink && proxy.$baiduMapPluginsSourceLink
                ? Object.assign(proxy.$baiduMapPluginsSourceLink, props.pluginsSourceLink)
                : props.pluginsSourceLink || proxy.$baiduMapPluginsSourceLink || {};
            const scriptKey = apiUrl || `_initBMap_${ak}`;
            // load sdk
            getScriptAsync({
                src: apiUrl ? apiUrl : `//api.map.baidu.com/api?type=webgl&v=1.0&ak=${ak}&callback=${scriptKey}`,
                addCalToWindow: !apiUrl,
                key: scriptKey,
                exportGetter: () => window.BMapGL
            })
                .then(() => {
                const { restrictCenter, enableIconClick, backgroundColor, minZoom, maxZoom, mapType, enableAutoResize, showControls, center, displayOptions } = props;
                if (!mapContainer.value)
                    return;
                map = new BMapGL.Map(mapContainer.value, {
                    backgroundColor,
                    enableIconClick,
                    restrictCenter,
                    minZoom,
                    maxZoom,
                    mapType: window[mapType],
                    enableAutoResize,
                    showControls,
                    displayOptions
                });
                setCenterAndZoom(center);
                initMapOptions();
                initCustomStyle();
                startWatchProps();
                bindEvents(props, vueEmits, map);
                if (plugins) {
                    initPlugins(plugins, pluginsSourceLink)
                        .then(() => {
                        vueEmits('pluginReady', map);
                    })
                        .catch((err) => {
                        error('BMap', 'plugins error: ' + err);
                    });
                }
                const event = {
                    map,
                    instance,
                    BMapGL: window.BMapGL
                };
                emit(instanceId, event);
                vueEmits('initd', event);
                initd.value = true;
            })
                .catch((e) => error('BMap', e.message));
        }
        // 个性化地图
        function initCustomStyle() {
            if (props.mapStyleId) {
                map.setMapStyleV2({
                    styleId: props.mapStyleId
                });
                return;
            }
            else if (props.mapStyleJson) {
                map.setMapStyleV2({
                    styleJson: props.mapStyleJson
                });
            }
        }
        // 监听props变化
        function startWatchProps() {
            watch(() => props.zoom, setZoom);
            watch(() => props.tilt, setTilt);
            watch(() => props.heading, setHeading);
            watch(() => props.center, callWhenDifferentValue(setCenterAndZoom), {
                deep: true
            });
            watch(() => props.mapStyleId, initCustomStyle);
            watch(() => props.mapStyleJson, callWhenDifferentValue(initCustomStyle), {
                deep: true
            });
            watch(() => props.displayOptions, callWhenDifferentValue(setDisplayOptions), {
                deep: true
            });
            watch(() => props.mapType, setMapType);
            watch(() => props.enableTraffic, setTraffic);
            watch(() => props.enableDragging, setDragging);
            watch(() => props.enableInertialDragging, setInertialDragging);
            watch(() => props.enableScrollWheelZoom, setScrollWheelZoom);
            watch(() => props.enableContinuousZoom, setContinuousZoom);
            watch(() => props.enableResizeOnCenter, setResizeOnCenter);
            watch(() => props.enableDoubleClickZoom, setDoubleClickZoom);
            watch(() => props.enableKeyboard, setKeyboard);
            watch(() => props.enablePinchToZoom, setPinchToZoom);
            watch(() => props.enableAutoResize, setAutoResize);
        }
        // 设置地图属性
        function initMapOptions() {
            const { enableDragging, enableInertialDragging, enableScrollWheelZoom, enableContinuousZoom, enableResizeOnCenter, enableDoubleClickZoom, enableKeyboard, enablePinchToZoom, enableAutoResize, enableTraffic, mapType, zoom, tilt, heading } = props;
            setZoom(zoom);
            setTilt(tilt);
            setTraffic(enableTraffic);
            setHeading(heading);
            setMapType(mapType);
            setKeyboard(enableKeyboard);
            setDragging(enableDragging);
            setAutoResize(enableAutoResize);
            setPinchToZoom(enablePinchToZoom);
            setContinuousZoom(enableContinuousZoom);
            setResizeOnCenter(enableResizeOnCenter);
            setDoubleClickZoom(enableDoubleClickZoom);
            setScrollWheelZoom(enableScrollWheelZoom);
            setInertialDragging(enableInertialDragging);
        }
        // 生产一个地理位置坐标点
        function genPoint(lng, lat) {
            return new BMapGL.Point(lng, lat);
        }
        /**
         * 设置是否显示路况图层
         */
        function setTraffic(enableTraffic) {
            enableTraffic ? map.setTrafficOn() : map.setTrafficOff();
        }
        /**
         * 设置中心点和缩放级别
         */
        function setCenterAndZoom(center) {
            if (typeof center === 'string') {
                map.centerAndZoom(center, props.zoom);
            }
            else {
                map.centerAndZoom(genPoint(center.lng, center.lat), props.zoom);
            }
        }
        /**
         * 设置地图自定义属性
         */
        function setDisplayOptions(displayOptions) {
            map.setDisplayOptions(displayOptions || {});
        }
        /**
         * 设置缩放级别
         */
        function setZoom(zoom) {
            map.setZoom(zoom, {
                noAnimation: props.noAnimation
            });
        }
        // 设置地图类型
        function setMapType(mapType) {
            window[mapType] !== undefined && map.setMapType(window[mapType]);
        }
        function setHeading(heading) {
            map.setHeading(heading);
        }
        function setTilt(tilt) {
            map.setTilt(tilt);
        }
        // 设置地图是否可拖动
        function setDragging(enableDragging) {
            enableDragging ? map.enableDragging() : map.disableDragging();
        }
        // 设置地图惯性拖拽
        function setInertialDragging(enableInertialDragging) {
            enableInertialDragging ? map.enableInertialDragging() : map.disableInertialDragging();
        }
        // 设置地图是否可滚轮缩放
        function setScrollWheelZoom(enableScrollWheelZoom) {
            enableScrollWheelZoom ? map.enableScrollWheelZoom() : map.disableScrollWheelZoom();
        }
        // 设置地图是否可连续缩放
        function setContinuousZoom(enableContinuousZoom) {
            enableContinuousZoom ? map.enableContinuousZoom() : map.disableContinuousZoom();
        }
        // 设置地图是否可缩放至中心点
        function setResizeOnCenter(enableResizeOnCenter) {
            enableResizeOnCenter ? map.enableResizeOnCenter() : map.disableResizeOnCenter();
        }
        // 设置地图是否可双击缩放
        function setDoubleClickZoom(enableDoubleClickZoom) {
            enableDoubleClickZoom ? map.enableDoubleClickZoom() : map.disableDoubleClickZoom();
        }
        // 设置地图是否可键盘操作
        function setKeyboard(enableKeyboard) {
            enableKeyboard ? map.enableKeyboard() : map.disableKeyboard();
        }
        // 设置地图是否可手势缩放
        function setPinchToZoom(enablePinchToZoom) {
            enablePinchToZoom ? map.enablePinchToZoom() : map.disablePinchToZoom();
        }
        // 设置地图是否自动适应窗口大小
        function setAutoResize(enableAutoResize) {
            enableAutoResize ? map.enableAutoResize() : map.disableAutoResize();
        }
        onMounted(init);
        /**
         * 销毁地图，当使用 WebGL 渲染地图时，如果确认不再使用该地图实例，则需要
         * 调用本方法销毁 WebGL 上下文，否则频繁创建新地图实例会导致浏览器报：
         * too many WebGL context 的警告。
         */
        onUnmounted(() => {
            if (map) {
                try {
                    map.destroy();
                }
                catch (e) {
                    error('BMapGL SDK', e.message);
                }
            }
        });
        __expose({
            // 父组件获取map实例方法
            getMapInstance: () => map,
            // 父组件/外部获取map组件 options
            getBaseMapOptions: () => props,
            // 重置地图中心
            resetCenter: () => setCenterAndZoom(props.center),
            // 设置地图是否可拖动
            setDragging
        });
        provide('getMapInstance', () => map);
        provide('baseMapSetCenterAndZoom', (_center) => setCenterAndZoom(_center));
        provide('baseMapSetDragging', (enableDragging) => setDragging(enableDragging));
        provide('getBaseMapOptions', () => props);
        return (_ctx, _cache) => {
            return (openBlock(), createElementBlock("div", { id: unref(instanceId) }, [
                (unref(shouldRender))
                    ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                        createElementVNode("div", {
                            class: "baidu-map-container",
                            ref_key: "mapContainer",
                            ref: mapContainer,
                            style: normalizeStyle([{ width: width.value, height: height.value, background: props.loadingBgColor }, { "position": "relative", "overflow": "hidden" }])
                        }, [
                            renderSlot(_ctx.$slots, "loading", {}, () => [
                                createElementVNode("div", {
                                    style: normalizeStyle([{ color: props.loadingTextColor }, { "position": "absolute", "top": "50%", "left": "50%", "transform": "translate(-50%, -50%)" }])
                                }, toDisplayString(!unref(initd) ? 'map loading...' : ''), 5)
                            ])
                        ], 4),
                        renderSlot(_ctx.$slots, "default")
                    ], 64))
                    : createCommentVNode("", true)
            ], 8, _hoisted_1$3));
        };
    } }));

/**
 * ### 监听父组件初始化，初始化完成调用 initdCallback 初始当前组件
 * root map 组件需要加载 sdk，所以它必定是异步的,
 * 子组件的初始化依赖于 root map 组件，当子组件初始化初始化root map 组件未初始化完成，就需要订阅他的初始化完成时间，这个事件触发了之后，再初始化当前组件,
 * 这是一个典型的发布订阅模式
 * 除根组件 Map 外,每个组件都可以是订阅者和发布者
 *
 * - 比如下面的组件层级:
 * ```text
 * |___Map 发布
 * |___|__Circle 订阅 / 发布
 * |___|___Marker 订阅 / 发布
 * |___|___|___ContextMenu 订阅
 * ```
 * @param initdCallback 初始当前组件
 * @returns
 */
function useParentComponentEffect(initdCallback) {
    const { on, off, emit } = usePubSub();
    const comInstance = getCurrentInstance();
    const currentInstanceId = useInstanceId();
    const { emit: vueEmit } = comInstance || { emit: noop };
    const getMapInstance = inject('getMapInstance', undefined);
    const parentComponentId = inject('parentComponentId', undefined);
    const parentUid = parentComponentId || '';
    const componentName = comInstance ? comInstance.type.name || '' : '';
    if (typeof getMapInstance === 'undefined') {
        process.env.NODE_ENV !== 'production' && error(componentName, 'must be a child node of the Bmap component');
        return { ready: noop };
    }
    const map = getMapInstance();
    let clearEffect;
    const initCallbackProxy = (event) => {
        clearEffect = initdCallback(event.map);
    };
    onMounted(() => {
        if (map) {
            initCallbackProxy({ map });
        }
        else {
            on(parentUid, initCallbackProxy);
        }
    });
    onBeforeUnmount(() => {
        try {
            clearEffect && clearEffect();
        }
        catch (e) {
            error(componentName, e.message);
        }
        vueEmit('unload');
        off(parentUid, initCallbackProxy);
    });
    return {
        ready: (map, instance) => {
            const eventPayload = {
                map,
                instance,
                BMapGL: window.BMapGL
            };
            vueEmit('initd', eventPayload);
            emit(currentInstanceId, eventPayload);
        }
    };
}

const _hoisted_1$2 = { style: { "display": "none" } };
var script$m = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BControl',
    inheritAttrs: false
}, { __name: 'index', props: {
        anchor: { default: 'BMAP_ANCHOR_TOP_LEFT' },
        offset: { default: () => ({ x: 83, y: 18 }) },
        visible: { type: Boolean, default: true }
    }, emits: ['initd', 'unload'], setup(__props) {
        const props = __props;
        const controlContainer = ref();
        const { ready } = useParentComponentEffect((map) => {
            if (!controlContainer.value) {
                if (process.env.NODE_ENV !== 'production') {
                    warn('BControl', 'container el render error');
                }
                return;
            }
            const { offset, anchor, visible } = props;
            const customControl = new BMapGL.Control();
            customControl.defaultAnchor = window[anchor];
            customControl.defaultOffset = new BMapGL.Size(offset.x, offset.y);
            customControl.initialize = (_map) => {
                return _map.getContainer().appendChild(controlContainer.value);
            };
            visible && map.addControl(customControl);
            ready(map, customControl);
            watch(() => props.visible, (n) => {
                map[n ? 'addControl' : 'removeControl'](customControl);
            });
            return () => map.removeControl(customControl);
        });
        return (_ctx, _cache) => {
            return (openBlock(), createElementBlock("div", _hoisted_1$2, [
                createElementVNode("div", mergeProps({
                    ref_key: "controlContainer",
                    ref: controlContainer
                }, _ctx.$attrs), [
                    renderSlot(_ctx.$slots, "default")
                ], 16)
            ]));
        };
    } }));

var script$l = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BScale'
}, { __name: 'index', props: {
        anchor: { default: 'BMAP_ANCHOR_BOTTOM_LEFT' },
        offset: { default: () => ({ x: 83, y: 18 }) },
        unit: { default: 'BMAP_UNIT_METRIC' },
        visible: { type: Boolean, default: true }
    }, emits: ['initd', 'unload'], setup(__props) {
        const props = __props;
        let scaleCtrl;
        const { ready } = useParentComponentEffect((map) => {
            const { visible, offset, anchor } = props;
            scaleCtrl = new BMapGL.ScaleControl({
                offset: new BMapGL.Size(offset.x, offset.y),
                anchor: window[anchor]
            });
            visible && map.addControl(scaleCtrl);
            setUnit();
            ready(map, scaleCtrl);
            watch(() => props.visible, (n) => {
                map[n ? 'addControl' : 'removeControl'](scaleCtrl);
            });
            return () => map.removeControl(scaleCtrl);
        });
        // 监听比例尺单位变化
        watch(() => props.unit, setUnit);
        /**
         * 设置比例尺单位制
         */
        function setUnit() {
            scaleCtrl.setUnit(window[props.unit]);
        }
        return (_ctx, _cache) => {
            return null;
        };
    } }));

var script$k = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BZoom'
}, { __name: 'index', props: {
        anchor: { default: 'BMAP_ANCHOR_BOTTOM_RIGHT' },
        offset: { default: () => ({ x: 83, y: 18 }) },
        visible: { type: Boolean, default: true }
    }, emits: ['initd', 'unload'], setup(__props) {
        const props = __props;
        let zoomControl;
        const { ready } = useParentComponentEffect((map) => {
            const { visible, offset, anchor } = props;
            zoomControl = new BMapGL.ZoomControl({
                offset: new BMapGL.Size(offset.x, offset.y),
                anchor: window[anchor]
            });
            visible && map.addControl(zoomControl);
            ready(map, zoomControl);
            watch(() => props.visible, (n) => {
                map[n ? 'addControl' : 'removeControl'](zoomControl);
            });
            return () => map.removeControl(zoomControl);
        });
        return (_ctx, _cache) => {
            return null;
        };
    } }));

var script$j = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BCityList'
}, { __name: 'index', props: {
        anchor: { default: 'BMAP_ANCHOR_TOP_LEFT' },
        offset: { default: () => ({ x: 18, y: 18 }) },
        expand: { type: Boolean, default: false },
        visible: { type: Boolean, default: true }
    }, emits: ['initd', 'unload'], setup(__props) {
        const props = __props;
        let cityListControl;
        const { ready } = useParentComponentEffect((map) => {
            const { visible, expand, offset, anchor } = props;
            cityListControl = new BMapGL.CityListControl({
                expand: expand,
                offset: new BMapGL.Size(offset.x, offset.y),
                anchor: window[anchor]
            });
            visible && map.addControl(cityListControl);
            ready(map, cityListControl);
            watch(() => props.visible, (n) => {
                map[n ? 'addControl' : 'removeControl'](cityListControl);
            });
            return () => map.removeControl(cityListControl);
        });
        return (_ctx, _cache) => {
            return null;
        };
    } }));

var script$i = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BLocation'
}, { __name: 'index', props: {
        anchor: { default: 'BMAP_ANCHOR_BOTTOM_RIGHT' },
        offset: { default: () => ({ x: 18, y: 18 }) },
        visible: { type: Boolean, default: true },
        onLocationError: {},
        onLocationSuccess: {}
    }, emits: ['initd', 'unload', 'locationSuccess', 'locationError'], setup(__props, { emit: vueEmits }) {
        const props = __props;
        let locationControl;
        const { ready } = useParentComponentEffect((map) => {
            const { visible, offset, anchor } = props;
            locationControl = new BMapGL.LocationControl({
                offset: new BMapGL.Size(offset.x, offset.y),
                anchor: window[anchor]
            });
            visible && map.addControl(locationControl);
            ready(map, locationControl);
            bindEvents(props, vueEmits, locationControl);
            watch(() => props.visible, (n) => {
                map[n ? 'addControl' : 'removeControl'](locationControl);
            });
            return () => map.removeControl(locationControl);
        });
        return (_ctx, _cache) => {
            return null;
        };
    } }));

const copyrightControlPosCacheMap = {};

const _hoisted_1$1 = { style: { "display": "none" } };
var script$h = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BCopyright',
    inheritAttrs: false
}, { __name: 'index', props: {
        anchor: { default: 'BMAP_ANCHOR_BOTTOM_RIGHT' },
        offset: { default: () => ({ x: 83, y: 18 }) },
        visible: { type: Boolean, default: true }
    }, emits: ['initd', 'unload'], setup(__props) {
        var _a;
        const props = __props;
        const copyrightContainer = ref();
        let copyrightControl;
        const uid = (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.uid;
        const { ready } = useParentComponentEffect((map) => {
            const { anchor, offset, visible } = props;
            if (!copyrightContainer.value) {
                if (process.env.NODE_ENV !== 'production') {
                    warn$1('BCopyright', 'container el render error');
                }
                return;
            }
            let mapBounds = map.getBounds();
            // 同一位置的 copyright 应该调用 addCopyright, 防止多个 copyright 重叠
            if (!(copyrightControl = copyrightControlPosCacheMap[anchor])) {
                copyrightControl = new BMapGL.CopyrightControl({
                    offset: new BMapGL.Size(offset.x, offset.y),
                    anchor: window[anchor]
                });
                copyrightControlPosCacheMap[anchor] = copyrightControl;
                map.addControl(copyrightControl);
            }
            if (visible) {
                copyrightControl.addCopyright({
                    id: uid,
                    content: copyrightContainer.value.innerHTML,
                    bounds: mapBounds
                });
            }
            ready(map, copyrightControl);
            watch(() => props.visible, (n) => {
                if (n) {
                    copyrightContainer.value &&
                        copyrightControl.addCopyright({
                            id: uid,
                            content: copyrightContainer.value.innerHTML,
                            bounds: mapBounds
                        });
                }
                else {
                    uid && copyrightControl.removeCopyright(uid);
                }
            });
            return () => {
                var _a, _b;
                const cacheCopyright = copyrightControlPosCacheMap[anchor];
                const getCopyrightCollection = (_a = cacheCopyright === null || cacheCopyright === void 0 ? void 0 : cacheCopyright.getCopyrightCollection) === null || _a === void 0 ? void 0 : _a.bind(cacheCopyright);
                if (getCopyrightCollection && ((_b = getCopyrightCollection()) === null || _b === void 0 ? void 0 : _b.length) > 1) {
                    cacheCopyright.removeCopyright(uid);
                }
                else {
                    map.removeControl(cacheCopyright);
                    Reflect.deleteProperty(copyrightControlPosCacheMap, anchor);
                }
            };
        });
        onUpdated(() => {
            if (!copyrightControl)
                return;
            let copyright = copyrightControl.getCopyright(uid);
            if (copyright && copyrightContainer.value && copyright.content !== copyrightContainer.value.innerHTML) {
                copyrightControl.addCopyright({
                    id: uid,
                    content: copyrightContainer.value.innerHTML,
                    bounds: copyright.bounds
                });
            }
        });
        return (_ctx, _cache) => {
            return (openBlock(), createElementBlock("div", _hoisted_1$1, [
                createElementVNode("div", mergeProps({
                    ref_key: "copyrightContainer",
                    ref: copyrightContainer
                }, _ctx.$attrs), [
                    renderSlot(_ctx.$slots, "default")
                ], 16)
            ]));
        };
    } }));

var script$g = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BNavigation3d'
}, { __name: 'index', props: {
        anchor: { default: 'BMAP_ANCHOR_BOTTOM_RIGHT' },
        offset: { default: () => ({ x: 83, y: 18 }) },
        visible: { type: Boolean, default: true }
    }, emits: ['initd', 'unload'], setup(__props) {
        const props = __props;
        let navigation3dControl;
        const { ready } = useParentComponentEffect((map) => {
            const { visible, offset, anchor } = props;
            navigation3dControl = new BMapGL.NavigationControl3D({
                offset: new BMapGL.Size(offset.x, offset.y),
                anchor: window[anchor]
            });
            visible && map.addControl(navigation3dControl);
            ready(map, navigation3dControl);
            watch(() => props.visible, (n) => {
                map[n ? 'addControl' : 'removeControl'](navigation3dControl);
            });
            return () => map.removeControl(navigation3dControl);
        });
        return (_ctx, _cache) => {
            return null;
        };
    } }));

var script$f = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BPanoramaControl'
}, { __name: 'index', props: {
        anchor: { default: 'BMAP_ANCHOR_TOP_RIGHT' },
        offset: { default: () => ({ x: 10, y: 10 }) },
        visible: { type: Boolean, default: true }
    }, emits: ['initd', 'unload'], setup(__props) {
        const props = __props;
        let panoramaControl;
        const { ready } = useParentComponentEffect((map) => {
            const { visible, offset, anchor } = props;
            panoramaControl = new BMapGL.PanoramaControl();
            panoramaControl.setOffset(new BMapGL.Size(offset.x, offset.y));
            panoramaControl.setAnchor(window[anchor]);
            visible && map.addControl(panoramaControl);
            ready(map, panoramaControl);
            watch(() => props.visible, (n) => {
                map[n ? 'addControl' : 'removeControl'](panoramaControl);
            });
            return () => map.removeControl(panoramaControl);
        });
        return (_ctx, _cache) => {
            return null;
        };
    } }));

var script$e = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BPanoramaCoverageLayer'
}, { __name: 'index', emits: ['initd', 'unload'], setup(__props) {
        let panoramaCoverageLayer;
        const { ready } = useParentComponentEffect((map) => {
            panoramaCoverageLayer = new BMapGL.PanoramaCoverageLayer();
            map.addTileLayer(panoramaCoverageLayer);
            ready(map, panoramaCoverageLayer);
            return () => map.removeTileLayer(panoramaCoverageLayer);
        });
        return (_ctx, _cache) => {
            return null;
        };
    } }));

var script$d = /*#__PURE__*/ defineComponent(Object.assign({ name: 'BMarker' }, { __name: 'index', props: {
        position: {},
        offset: { default: () => ({
                x: 0,
                y: 0
            }) },
        icon: {},
        zIndex: {},
        enableMassClear: { type: Boolean, default: true },
        enableDragging: { type: Boolean, default: false },
        enableClicking: { type: Boolean, default: true },
        raiseOnDrag: { type: Boolean, default: false },
        draggingCursor: { default: 'pointer' },
        rotation: { default: 0 },
        title: { default: '' },
        visible: { type: Boolean, default: true },
        onClick: {},
        onDblclick: {},
        onMousedown: {},
        onMouseup: {},
        onMouseout: {},
        onMouseover: {},
        onRemove: {},
        onInfowindowclose: {},
        onInfowindowopen: {},
        onDragstart: {},
        onDragging: {},
        onDragend: {},
        onRightClick: {}
    }, emits: [
        'initd',
        'unload',
        'click',
        'dblclick',
        'mousedown',
        'mouseup',
        'mouseout',
        'mouseover',
        'remove',
        'infowindowclose',
        'infowindowopen',
        'dragstart',
        'dragging',
        'dragend',
        'rightclick'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        let marker;
        const { ready } = useParentComponentEffect((map) => {
            const cal = () => {
                marker && map.removeOverlay(marker);
            };
            const init = () => {
                if (!props.position) {
                    return process.env.NODE_ENV !== 'production' && warn('BMarker', 'position is required');
                }
                const { position, offset, enableMassClear, enableDragging, enableClicking, raiseOnDrag, draggingCursor, rotation, title, icon, zIndex, visible } = props;
                const options = {
                    offset: new BMapGL.Size(offset.x, offset.y),
                    enableMassClear,
                    enableDragging,
                    enableClicking,
                    raiseOnDrag,
                    draggingCursor,
                    title
                };
                if (icon) {
                    options.icon = getIconConfig();
                }
                marker = new BMapGL.Marker(new BMapGL.Point(position.lng, position.lat), options);
                setRotation(rotation);
                isDef(zIndex) && setZIndex(zIndex);
                // 在地图上添加点标记
                visible && map.addOverlay(marker);
                bindEvents(props, vueEmits, marker);
                ready(map, marker);
            };
            init();
            // 监听值变化
            watch(() => props.position, callWhenDifferentValue((n) => {
                marker ? setPosition(n) : init();
            }), { deep: true });
            watch(() => props.icon, callWhenDifferentValue(setIcon), { deep: true });
            watch(() => props.offset, callWhenDifferentValue(setOffset), { deep: true });
            watch(() => props.enableDragging, setDragging);
            watch(() => props.enableMassClear, setMassClear);
            watch(() => props.rotation, setRotation);
            watch(() => props.visible, (n) => {
                map[n ? 'addOverlay' : 'removeOverlay'](marker);
            });
            return cal;
        });
        provide('getOverlayInstance', () => marker);
        // 获取图标配置
        function getIconConfig() {
            const defaultIcons = useDefaultMarkerIcons();
            const { icon } = props;
            if (isString(icon) && defaultIcons[icon]) {
                return defaultIcons[icon];
            }
            else {
                // @ts-ignore
                const { anchor, imageOffset, imageSize, imageUrl, printImageUrl } = icon;
                const iconOptions = {
                    imageSize: new BMapGL.Size(imageSize.width, imageSize.height)
                };
                if (anchor) {
                    iconOptions.anchor = new BMapGL.Size(anchor.x, anchor.y);
                }
                if (imageOffset) {
                    iconOptions.imageOffset = new BMapGL.Size(imageOffset.x, imageOffset.y);
                }
                if (printImageUrl) {
                    iconOptions.printImageUrl = printImageUrl;
                }
                return new BMapGL.Icon(imageUrl, new BMapGL.Size(imageSize.width, imageSize.height), iconOptions);
            }
        }
        function setZIndex(zIndex) {
            marker.setZIndex(zIndex);
        }
        function setPosition(position) {
            position && position.lat && position.lng && marker.setPosition(new BMapGL.Point(position.lng, position.lat));
        }
        function setIcon() {
            marker.setIcon(getIconConfig());
        }
        function setDragging(enableDragging) {
            enableDragging ? marker.enableDragging() : marker.disableDragging();
        }
        function setMassClear(enableMassClear) {
            enableMassClear ? marker.enableMassClear() : marker.disableMassClear();
        }
        function setOffset(offset) {
            offset && marker.setOffset(new BMapGL.Size(offset.x, offset.y));
        }
        function setRotation(rotation) {
            rotation !== undefined && marker.setRotation(rotation);
        }
        return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
        };
    } }));

var script$c = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BMarker3d'
}, { __name: 'index', props: {
        position: {},
        height: {},
        size: { default: 50 },
        shape: { default: 'BMAP_SHAPE_CIRCLE' },
        fillColor: { default: '#f00' },
        fillOpacity: { default: 0.8 },
        icon: {},
        enableMassClear: { type: Boolean, default: true },
        visible: { type: Boolean, default: true },
        onClick: {},
        onDblclick: {},
        onMousedown: {},
        onMouseup: {},
        onMouseout: {},
        onMouseover: {},
        onRemove: {},
        onRightClick: {}
    }, emits: [
        'initd',
        'unload',
        'click',
        'dblclick',
        'mousedown',
        'mouseup',
        'mouseout',
        'mouseover',
        'remove',
        'rightclick'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        let marker3d;
        const { ready } = useParentComponentEffect((map) => {
            const cal = () => {
                map.removeOverlay(marker3d);
            };
            const init = () => {
                if (!props.position)
                    return process.env.NODE_ENV !== 'production' && warn('Marker3d', 'position is required');
                if (!props.height)
                    return process.env.NODE_ENV !== 'production' && warn('Marker3d', 'height is required');
                const { position, shape, fillColor, fillOpacity, size, icon, height, enableMassClear, visible } = props;
                const options = {
                    size,
                    fillColor,
                    fillOpacity,
                    shape: window[shape]
                };
                if (icon) {
                    options.icon = getIconConfig();
                }
                marker3d = new BMapGL.Marker3D(new BMapGL.Point(position.lng, position.lat), height, options);
                // 在地图上添加点标记
                visible && map.addOverlay(marker3d);
                setMassClear(enableMassClear);
                bindEvents(props, vueEmits, marker3d);
                ready(map, marker3d);
            };
            init();
            // 监听值变化
            watch(() => props.position, callWhenDifferentValue((n) => {
                marker3d ? setPosition(n) : init();
            }), { deep: true });
            watch(() => props.height, (n) => {
                marker3d ? setHeight(n) : init();
            });
            watch(() => props.enableMassClear, setMassClear);
            watch(() => props.icon, callWhenDifferentValue(setIcon), { deep: true });
            watch(() => props.enableMassClear, setMassClear);
            watch(() => props.fillOpacity, setFillOpacity);
            watch(() => props.fillColor, setFillColor);
            watch(() => props.visible, (n) => {
                map[n ? 'addOverlay' : 'removeOverlay'](marker3d);
            });
            return cal;
        });
        provide('getOverlayInstance', () => marker3d);
        // 获取图标配置
        function getIconConfig() {
            const { icon } = props;
            // @ts-ignore
            const { anchor, imageOffset, imageSize, imageUrl, printImageUrl } = icon;
            const iconOptions = {
                imageSize: new BMapGL.Size(imageSize.width, imageSize.height)
            };
            if (anchor) {
                iconOptions.anchor = new BMapGL.Size(anchor.x, anchor.y);
            }
            if (imageOffset) {
                iconOptions.imageOffset = new BMapGL.Size(imageOffset.x, imageOffset.y);
            }
            if (printImageUrl) {
                iconOptions.printImageUrl = printImageUrl;
            }
            return new BMapGL.Icon(imageUrl, new BMapGL.Size(imageSize.width, imageSize.height), iconOptions);
        }
        function setPosition(position) {
            try {
                // FIXME: 更新 position baidu-map-gl api报错: TypeError: Cannot read properties of undefined (reading '2x')
                marker3d.setPosition(new BMapGL.Point(position.lng, position.lat));
            }
            catch (error) {
                console.error(error);
            }
        }
        function setHeight(height) {
            marker3d.setHeight(height);
        }
        function setFillColor(color) {
            marker3d.setFillColor(color);
        }
        function setFillOpacity(opacity) {
            marker3d.setFillOpacity(opacity);
        }
        function setIcon() {
            marker3d.setIcon(getIconConfig());
        }
        function setMassClear(enableMassClear) {
            enableMassClear ? marker3d.enableMassClear() : marker3d.disableMassClear();
        }
        return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
        };
    } }));

var script$b = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BLabel'
}, { __name: 'index', props: {
        content: {},
        position: {},
        offset: { default: () => ({
                x: 0,
                y: 0
            }) },
        zIndex: {},
        style: {},
        enableMassClear: { type: Boolean, default: true },
        visible: { type: Boolean, default: true },
        onClick: {},
        onDblclick: {},
        onMousedown: {},
        onMouseup: {},
        onMouseout: {},
        onMouseover: {},
        onRemove: {},
        onRightclick: {}
    }, emits: [
        'initd',
        'unload',
        'click',
        'dblclick',
        'mousedown',
        'mouseup',
        'mouseout',
        'mouseover',
        'remove',
        'rightclick'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        let label;
        const hasLabel = () => !!label;
        const { ready } = useParentComponentEffect((map) => {
            const cal = () => {
                label && map.removeOverlay(label);
            };
            const init = () => {
                if (!props.content)
                    return process.env.NODE_ENV !== 'production' && warn('BLabel', 'content is required');
                if (!props.position)
                    return process.env.NODE_ENV !== 'production' && warn('BLabel', 'position is required');
                const { content, position, offset, enableMassClear, style, visible, zIndex } = props;
                const options = {
                    position: new BMapGL.Point(position.lng, position.lat),
                    offset: new BMapGL.Size(offset.x, offset.y),
                    enableMassClear
                };
                label = new BMapGL.Label(content, options);
                // 自定义文本标注样式
                if (style) {
                    label.setStyle(style);
                }
                visible && map.addOverlay(label);
                isDef(zIndex) && setZIndex(zIndex);
                bindEvents(props, vueEmits, label);
                watch(() => props.offset, callWhenDifferentValue(setOffset), { deep: true });
                watch(() => props.style, callWhenDifferentValue(setStyle), { deep: true });
                watch(() => props.enableMassClear, setMassClear);
                watch(() => props.zIndex, setZIndex);
                watch(() => props.visible, (n) => {
                    map[n ? 'addOverlay' : 'removeOverlay'](label);
                });
            };
            init();
            ready(map, label);
            // 监听值变化
            watch(() => props.position, callWhenDifferentValue(conditionalCall(hasLabel, setPosition, init)), { deep: true });
            watch(() => props.content, conditionalCall(hasLabel, setContent, init));
            return cal;
        });
        provide('getOverlayInstance', () => label);
        function setZIndex(zIndex) {
            isDef(zIndex) && label.setZIndex(zIndex);
        }
        function setPosition(position) {
            label.setPosition(new BMapGL.Point(position.lng, position.lat));
        }
        function setStyle(styles) {
            if (isDef(styles))
                label.setStyle(styles);
        }
        function setContent(content) {
            label.setContent(content);
        }
        function setOffset(offset) {
            label.setOffset(new BMapGL.Size(offset.x, offset.y));
        }
        function setMassClear(enableMassClear) {
            enableMassClear ? label.enableMassClear() : label.disableMassClear();
        }
        return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
        };
    } }));

var script$a = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BPolyline'
}, { __name: 'index', props: {
        path: {},
        strokeColor: { default: '#000' },
        strokeWeight: { default: 2 },
        strokeOpacity: { default: 1 },
        strokeStyle: { default: 'solid' },
        enableMassClear: { type: Boolean, default: true },
        enableEditing: { type: Boolean, default: false },
        enableClicking: { type: Boolean, default: true },
        geodesic: { type: Boolean, default: false },
        clip: { type: Boolean, default: true },
        linkRight: { type: Boolean, default: true },
        visible: { type: Boolean, default: true },
        onClick: {},
        onDblclick: {},
        onMousedown: {},
        onMouseup: {},
        onMouseout: {},
        onMouseover: {},
        onRemove: {},
        onLineupdate: {}
    }, emits: [
        'initd',
        'unload',
        'click',
        'dblclick',
        'mousedown',
        'mouseup',
        'mouseout',
        'mouseover',
        'remove',
        'lineupdate'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        let polyline;
        const { ready } = useParentComponentEffect((map) => {
            const clear = () => {
                polyline && map.removeOverlay(polyline);
            };
            const init = () => {
                if (!props.path || !props.path.length)
                    return process.env.NODE_ENV !== 'production' && warn('BPolyline', 'path is required and not empty array');
                const { path, strokeColor, strokeWeight, strokeOpacity, strokeStyle, enableMassClear, enableEditing, enableClicking, geodesic, clip, linkRight, visible } = props;
                const pathPoints = pathPointsToMapPoints(path);
                polyline = new BMapGL.Polyline(pathPoints, {
                    strokeColor,
                    strokeWeight,
                    strokeOpacity,
                    strokeStyle,
                    enableMassClear,
                    enableEditing,
                    enableClicking,
                    geodesic,
                    linkRight,
                    clip
                });
                visible && map.addOverlay(polyline);
                bindEvents(props, vueEmits, polyline);
                ready(map, polyline);
                watch(() => props.strokeColor, setStrokeColor);
                watch(() => props.strokeOpacity, setStrokeOpacity);
                watch(() => props.strokeWeight, setStrokeWeight);
                watch(() => props.strokeStyle, setStrokeStyle);
                watch(() => props.enableMassClear, setMassClear);
                watch(() => props.enableEditing, setEditing);
            };
            init();
            // 监听值变化
            watch(() => props.path, callWhenDifferentValue((n) => {
                if (polyline) {
                    n.length ? setPath(n) : clear();
                }
                else {
                    init();
                }
            }), {
                deep: true
            });
            watch(() => props.visible, (n) => {
                map[n ? 'addOverlay' : 'removeOverlay'](polyline);
            });
            return clear;
        });
        provide('getOverlayInstance', () => polyline);
        function setPath(path) {
            polyline && polyline.setPath(pathPointsToMapPoints(path));
        }
        function setStrokeColor(color) {
            polyline && polyline.setStrokeColor(color);
        }
        function setStrokeOpacity(opacity) {
            polyline && polyline.setStrokeOpacity(opacity);
        }
        function setStrokeWeight(weight) {
            polyline && polyline.setStrokeWeight(weight);
        }
        function setStrokeStyle(style) {
            polyline && polyline.setStrokeStyle(style);
        }
        function setMassClear(enableMassClear) {
            if (polyline) {
                enableMassClear ? polyline.enableMassClear() : polyline.disableMassClear();
            }
        }
        function setEditing(enableEditing) {
            if (polyline) {
                enableEditing ? polyline.enableEditing() : polyline.disableEditing();
            }
        }
        return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
        };
    } }));

var script$9 = /*#__PURE__*/ defineComponent(Object.assign({ name: 'BBezierCurve' }, { __name: 'index', props: {
        path: {},
        controlPoints: {},
        strokeColor: { default: '#000' },
        strokeWeight: { default: 2 },
        strokeOpacity: { default: 1 },
        strokeStyle: { default: 'solid' },
        enableMassClear: { type: Boolean, default: true },
        visible: { type: Boolean, default: true },
        onClick: {},
        onDblclick: {},
        onMousedown: {},
        onMouseup: {},
        onMouseout: {},
        onMouseover: {},
        onRemove: {},
        onLineupdate: {}
    }, emits: [
        'initd',
        'unload',
        'click',
        'dblclick',
        'mousedown',
        'mouseup',
        'mouseout',
        'mouseover',
        'remove',
        'lineupdate'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        let bezierCurve;
        const { ready } = useParentComponentEffect((map) => {
            const cal = () => {
                map.removeOverlay(bezierCurve);
            };
            const init = () => {
                if (!props.path || !(props.path && props.path.length))
                    return process.env.NODE_ENV !== 'production' && warn('BezierCurve', 'path props is required or not empty array');
                if (!props.controlPoints || !(props.controlPoints && props.controlPoints.length))
                    return process.env.NODE_ENV !== 'production' && warn('BezierCurve', 'controlPoints props is required or not empty array');
                const { path, controlPoints, strokeColor, strokeWeight, strokeOpacity, strokeStyle, enableMassClear, visible } = props;
                const pathPoints = pathPointsToMapPoints(path);
                const _controlPoints = controlPoints.map((points) => {
                    return pathPointsToMapPoints(points);
                });
                try {
                    bezierCurve = new BMapGL.BezierCurve(pathPoints, _controlPoints, {
                        strokeColor,
                        strokeWeight,
                        strokeOpacity,
                        strokeStyle,
                        enableMassClear
                    });
                }
                catch (e) {
                    if (process.env.NODE_ENV !== 'production')
                        error('BezierCurve', e.message || 'Init bezierCurve overlay error, make sure path and controlPoints data is correct!');
                }
                visible && map.addOverlay(bezierCurve);
                ready(map, bezierCurve);
                bindEvents(props, vueEmits, bezierCurve);
            };
            init();
            // 监听值变化
            watch(() => props.path, callWhenDifferentValue((n) => {
                bezierCurve ? setPath(n) : init();
            }), {
                deep: true
            });
            watch(() => props.controlPoints, callWhenDifferentValue((n) => {
                bezierCurve ? setControlPoints(n) : init();
            }), {
                deep: true
            });
            watch(() => props.strokeColor, setStrokeColor);
            watch(() => props.strokeOpacity, setStrokeOpacity);
            watch(() => props.strokeWeight, setStrokeWeight);
            watch(() => props.strokeStyle, setStrokeStyle);
            watch(() => props.enableMassClear, setMassClear);
            watch(() => props.visible, (n) => {
                map[n ? 'addOverlay' : 'removeOverlay'](bezierCurve);
            });
            return cal;
        });
        provide('getOverlayInstance', () => bezierCurve);
        function setPath(path) {
            bezierCurve.setPath(pathPointsToMapPoints(path));
        }
        function setControlPoints(points) {
            bezierCurve.setControlPoints(points.map((points) => pathPointsToMapPoints(points)));
        }
        function setStrokeColor(color) {
            bezierCurve.setStrokeColor(color);
        }
        function setStrokeOpacity(opacity) {
            bezierCurve.setStrokeOpacity(opacity);
        }
        function setStrokeWeight(weight) {
            bezierCurve.setStrokeWeight(weight);
        }
        function setStrokeStyle(style) {
            bezierCurve.setStrokeStyle(style);
        }
        function setMassClear(enableMassClear) {
            enableMassClear ? bezierCurve.enableMassClear() : bezierCurve.disableMassClear();
        }
        return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
        };
    } }));

var script$8 = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BPolygon'
}, { __name: 'index', props: {
        path: {},
        isBoundary: { type: Boolean },
        strokeColor: { default: '#000' },
        autoCenter: { type: Boolean, default: true },
        strokeWeight: { default: 2 },
        strokeOpacity: { default: 1 },
        strokeStyle: { default: 'solid' },
        fillColor: { default: '#fff' },
        fillOpacity: { default: 0.3 },
        enableMassClear: { type: Boolean },
        enableEditing: { type: Boolean },
        enableClicking: { type: Boolean },
        geodesic: { type: Boolean, default: false },
        clip: { type: Boolean, default: true },
        visible: { type: Boolean, default: true },
        onClick: {},
        onDblclick: {},
        onMousedown: {},
        onMouseup: {},
        onMouseout: {},
        onMouseover: {},
        onRemove: {},
        onLineupdate: {}
    }, emits: [
        'initd',
        'unload',
        'click',
        'dblclick',
        'mousedown',
        'mouseup',
        'mouseout',
        'mouseover',
        'remove',
        'lineupdate'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        const injectBaseMapSetCenterAndZoom = inject('baseMapSetCenterAndZoom');
        let polygon;
        const { ready } = useParentComponentEffect((map) => {
            const cal = () => {
                polygon && map.removeOverlay(polygon);
            };
            const init = () => {
                if (!props.path)
                    return process.env.NODE_ENV !== 'production' && warn('BPolygon', 'path is required');
                if (!props.path.length)
                    return;
                const { path, strokeColor, strokeWeight, strokeOpacity, strokeStyle, fillOpacity, fillColor, enableMassClear, enableEditing, enableClicking, geodesic, clip, isBoundary, visible } = props;
                const pathPoints = isBoundary ? path : pathPointsToMapPoints(path);
                if (!pathPoints)
                    return;
                polygon = new BMapGL.Polygon(pathPoints, {
                    strokeColor,
                    strokeWeight,
                    strokeOpacity,
                    strokeStyle,
                    fillOpacity,
                    fillColor,
                    enableMassClear,
                    enableEditing,
                    enableClicking,
                    geodesic,
                    clip
                });
                visible && map.addOverlay(polygon);
                visible && syncMapCenter();
                bindEvents(props, vueEmits, polygon);
                ready(map, polygon);
                // 监听值变化, 初始为空时不会初始化, 不为空值时初始化
                watch(() => props.strokeColor, setStrokeColor);
                watch(() => props.strokeOpacity, setStrokeOpacity);
                watch(() => props.fillColor, setFillColor);
                watch(() => props.fillOpacity, setFillOpacity);
                watch(() => props.strokeWeight, setStrokeWeight);
                watch(() => props.strokeStyle, setStrokeStyle);
                watch(() => props.enableMassClear, setMassClear);
                watch(() => props.enableEditing, setEditing);
                watch(() => props.visible, (n) => {
                    map[n ? 'addOverlay' : 'removeOverlay'](polygon);
                    n && syncMapCenter();
                });
            };
            init();
            watch(() => props.path, callWhenDifferentValue((path) => {
                polygon ? setPath(path) : init();
            }), {
                deep: true
            });
            return cal;
        });
        provide('getOverlayInstance', () => polygon);
        function syncMapCenter() {
            nextTick(() => {
                // 自动设置中心点
                if (props.autoCenter) {
                    // 获取中心点
                    try {
                        const bounds = polygon.getBounds();
                        if (bounds) {
                            const center = bounds.getCenter();
                            center && injectBaseMapSetCenterAndZoom(center);
                        }
                    }
                    catch (e) {
                        console.warn('BPolygon', 'auto set center error', e);
                    }
                }
            });
        }
        function setPath(path) {
            const { isBoundary } = props;
            polygon.setPath(isBoundary ? path : pathPointsToMapPoints(path));
            syncMapCenter();
        }
        function setStrokeColor(color) {
            polygon && polygon.setStrokeColor(color);
        }
        function setFillColor(color) {
            polygon && polygon.setFillColor(color);
        }
        function setStrokeOpacity(opacity) {
            polygon && polygon.setStrokeOpacity(opacity);
        }
        function setFillOpacity(opacity) {
            polygon && polygon.setFillOpacity(opacity);
        }
        function setStrokeWeight(weight) {
            polygon && polygon.setStrokeWeight(weight);
        }
        function setStrokeStyle(style) {
            polygon && polygon.setStrokeStyle(style);
        }
        function setMassClear(enableMassClear) {
            if (polygon)
                enableMassClear ? polygon.enableMassClear() : polygon.disableMassClear();
        }
        function setEditing(enableEditing) {
            if (polygon)
                enableEditing ? polygon.enableEditing() : polygon.disableEditing();
        }
        return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
        };
    } }));

const _hoisted_1 = { style: { "display": "none" } };
var script$7 = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BInfoWindow'
}, { __name: 'index', props: {
        modelValue: { type: Boolean, default: undefined },
        show: { type: Boolean, default: false },
        title: { default: '' },
        position: {},
        width: { default: 0 },
        height: { default: 0 },
        maxWidth: { default: 220 },
        offset: { default: () => ({
                x: 0,
                y: 0
            }) },
        enableAutoPan: { type: Boolean, default: true },
        enableCloseOnClick: { type: Boolean, default: true },
        onClose: {},
        onOpen: {},
        onMaximize: {},
        onRestore: {},
        onClickclose: {}
    }, emits: ['initd', 'unload', 'close', 'open', 'maximize', 'restore', 'clickclose', 'update:show'], setup(__props, { emit: vueEmits }) {
        const props = __props;
        const visible = computed({
            get: () => props.show,
            set: (value) => vueEmits('update:show', value)
        });
        const infoWindowContainer = ref();
        let infoWindow;
        let _map;
        watchEffect(() => {
            if (typeof props.modelValue !== 'undefined' && process.env.NODE_ENV !== 'production') {
                warnOnce('BInfoWindow', '`v-model` is deprecated, please use `v-model:show` instead.');
            }
        });
        const { ready } = useParentComponentEffect((map) => {
            _map = map;
            const clear = () => {
                infoWindow && map.removeOverlay(infoWindow);
            };
            const init = () => {
                const { title, width, height, enableAutoPan, maxWidth, offset, enableCloseOnClick } = props;
                const options = {
                    width,
                    height,
                    title,
                    maxWidth,
                    enableAutoPan,
                    enableCloseOnClick,
                    offset: new BMapGL.Size(offset.x, offset.y)
                };
                infoWindow = new BMapGL.InfoWindow(infoWindowContainer.value || '', options);
                infoWindow.addEventListener('close', () => {
                    if (props.show)
                        visible.value = false;
                });
                infoWindow.addEventListener('open', () => {
                    if (!props.show)
                        visible.value = true;
                });
                map.addOverlay(infoWindow);
                redraw();
                bindObserver();
                bindEvents(props, vueEmits, infoWindow);
                ready(map, infoWindow);
                if (props.show) {
                    // 多个 infoWindow, 显示最后一个实例, 其他实例同步显隐状态
                    nextTick(() => {
                        open();
                        nextTick(() => {
                            !infoWindow._visible && (visible.value = false);
                        });
                    });
                }
            };
            if (!infoWindowContainer.value) {
                nextTick(() => init());
            }
            else {
                init();
            }
            // 监听值变化
            watch(() => props.position, callWhenDifferentValue((position) => setPosition(position)), { deep: true });
            watch(() => props.title, setTitle);
            watch(() => props.width, setWidth);
            watch(() => props.height, setHeight);
            watch(() => props.maxWidth, setMaxWidth);
            watch(() => props.enableAutoPan, setAutoPan);
            watch(() => props.enableCloseOnClick, setCloseOnClick);
            watch(() => props.show, callWhenDifferentValue(() => {
                props.show ? open() : close();
            }));
            return clear;
        });
        onUpdated(() => {
            if (infoWindow && infoWindow.isOpen()) {
                setContent(infoWindowContainer.value || '');
                redraw();
            }
        });
        provide('getOverlayInstance', () => infoWindow);
        function bindObserver() {
            const MutationObserver = window.MutationObserver;
            if (!MutationObserver) {
                return;
            }
            new MutationObserver(() => {
                infoWindow.redraw();
            }).observe(infoWindowContainer.value, { attributes: true, childList: true, characterData: true, subtree: true });
        }
        function open() {
            const { position } = props;
            if (!position || !infoWindow)
                return;
            _map.openInfoWindow(infoWindow, new BMapGL.Point(position.lng, position.lat));
            visible.value = true;
        }
        function close() {
            if (!infoWindow)
                return;
            infoWindow.hide();
            visible.value = false;
        }
        function redraw() {
            var _a;
            infoWindow.redraw();
            Array.prototype.forEach.call(((_a = infoWindowContainer.value) === null || _a === void 0 ? void 0 : _a.querySelectorAll('img')) || [], (imgEl) => {
                imgEl.onload = () => {
                    infoWindow.redraw();
                };
            });
        }
        function setTitle(title) {
            infoWindow.setTitle(title);
        }
        function setHeight(height) {
            infoWindow.setHeight(height);
        }
        function setWidth(width) {
            infoWindow.setWidth(width);
        }
        function setMaxWidth(maxWidth) {
            infoWindow.setMaxWidth(maxWidth);
        }
        // function setMaximize(maximize: boolean) {
        // 	maximize ? infoWindow.enableMaximize() : infoWindow.disableMaximize()
        // }
        function setAutoPan(autoPan) {
            autoPan ? infoWindow.enableAutoPan() : infoWindow.disableAutoPan();
        }
        function setCloseOnClick(closeOnClick) {
            closeOnClick ? infoWindow.enableCloseOnClick() : infoWindow.disableCloseOnClick();
        }
        function setPosition(position) {
            open();
            infoWindow.setPosition(new BMapGL.Point(position.lng, position.lat));
            if (!visible.value)
                close();
        }
        function setContent(content) {
            infoWindow.setContent(content);
        }
        return (_ctx, _cache) => {
            return (openBlock(), createElementBlock("div", _hoisted_1, [
                createElementVNode("div", mergeProps({
                    ref_key: "infoWindowContainer",
                    ref: infoWindowContainer
                }, _ctx.$attrs), [
                    renderSlot(_ctx.$slots, "default")
                ], 16)
            ]));
        };
    } }));

var script$6 = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BCircle'
}, { __name: 'index', props: {
        center: {},
        radius: {},
        strokeColor: { default: '#000' },
        strokeOpacity: { default: 1 },
        fillColor: { default: '#fff' },
        fillOpacity: { default: 0.3 },
        strokeWeight: { default: 2 },
        strokeStyle: { default: 'solid' },
        enableMassClear: { type: Boolean, default: true },
        enableEditing: { type: Boolean, default: false },
        enableClicking: { type: Boolean, default: true },
        geodesic: { type: Boolean, default: false },
        clip: { type: Boolean, default: true },
        visible: { type: Boolean, default: true },
        onClick: {},
        onDblclick: {},
        onMousedown: {},
        onMouseup: {},
        onMouseout: {},
        onMouseover: {},
        onRemove: {},
        onLineupdate: {}
    }, emits: [
        'initd',
        'unload',
        'click',
        'dblclick',
        'mousedown',
        'mouseup',
        'mouseout',
        'mouseover',
        'remove',
        'lineupdate'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        let circle;
        const { ready } = useParentComponentEffect((map) => {
            const cal = () => {
                map.removeOverlay(circle);
            };
            const init = () => {
                if (process.env.NODE_ENV !== 'production') {
                    if (!props.center)
                        return warn('BCircle', 'center props is required');
                    if (!props.radius)
                        return warn('BCircle', 'radius props is required');
                }
                const { center, radius, strokeColor, strokeOpacity, fillColor, fillOpacity, strokeWeight, strokeStyle, enableMassClear, enableEditing, enableClicking, geodesic, clip, visible } = props;
                const centerPoint = new BMapGL.Point(center.lng, center.lat);
                circle = new BMapGL.Circle(centerPoint, radius, {
                    strokeColor,
                    strokeWeight,
                    strokeOpacity,
                    strokeStyle,
                    enableMassClear,
                    enableEditing,
                    enableClicking,
                    geodesic,
                    clip,
                    fillOpacity,
                    fillColor
                });
                visible && map.addOverlay(circle);
                bindEvents(props, vueEmits, circle);
                ready(map, circle);
            };
            init();
            // 监听值变化
            watch(() => props.center, callWhenDifferentValue(setCenter), { deep: true });
            watch(() => props.radius, setRadius);
            watch(() => props.strokeColor, setStrokeColor);
            watch(() => props.strokeOpacity, setStrokeOpacity);
            watch(() => props.fillColor, setFillColor);
            watch(() => props.fillOpacity, setFillOpacity);
            watch(() => props.strokeWeight, setStrokeWeight);
            watch(() => props.strokeStyle, setStrokeStyle);
            watch(() => props.enableMassClear, setMassClear);
            watch(() => props.enableEditing, setEditing);
            watch(() => props.visible, (n) => {
                map[n ? 'addOverlay' : 'removeOverlay'](circle);
            });
            return cal;
        });
        provide('getOverlayInstance', () => circle);
        function setRadius(radius) {
            circle.setRadius(radius);
        }
        function setCenter(center) {
            if (circle) {
                circle.setCenter(new BMapGL.Point(center.lng, center.lat));
            }
        }
        function setStrokeColor(color) {
            circle.setStrokeColor(color);
        }
        function setFillColor(color) {
            circle.setFillColor(color);
        }
        function setStrokeOpacity(opacity) {
            circle.setStrokeOpacity(opacity);
        }
        function setFillOpacity(opacity) {
            circle.setFillOpacity(opacity);
        }
        function setStrokeWeight(weight) {
            circle.setStrokeWeight(weight);
        }
        function setStrokeStyle(style) {
            circle.setStrokeStyle(style);
        }
        function setMassClear(enableMassClear) {
            enableMassClear ? circle.enableMassClear() : circle.disableMassClear();
        }
        function setEditing(enableEditing) {
            enableEditing ? circle.enableEditing() : circle.disableEditing();
        }
        return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
        };
    } }));

var script$5 = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BPrism'
}, { __name: 'index', props: {
        path: {},
        altitude: {},
        isBoundary: { type: Boolean },
        topFillColor: { default: '#fff' },
        topFillOpacity: { default: 0.5 },
        sideFillColor: { default: '#fff' },
        sideFillOpacity: { default: 0.8 },
        autoCenter: { type: Boolean, default: true },
        enableMassClear: { type: Boolean, default: true },
        visible: { type: Boolean, default: true },
        onClick: {},
        onDblclick: {},
        onMousedown: {},
        onMouseup: {},
        onMouseout: {},
        onMouseover: {},
        onRemove: {},
        onLineupdate: {}
    }, emits: [
        'initd',
        'unload',
        'click',
        'dblclick',
        'mousedown',
        'mouseup',
        'mouseout',
        'mouseover',
        'remove',
        'lineupdate'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        const injectBaseMapSetCenterAndZoom = inject('baseMapSetCenterAndZoom');
        let prism;
        const { ready } = useParentComponentEffect((map) => {
            const clear = () => {
                prism && map.removeOverlay(prism);
            };
            const init = () => {
                if (!props.path || !(props.path && props.path.length))
                    return process.env.NODE_ENV !== 'production' && warn('BPrism', 'path is required');
                const { path, altitude, isBoundary, topFillColor, topFillOpacity, sideFillColor, sideFillOpacity, enableMassClear, visible } = props;
                const pathPoints = isBoundary ? path : pathPointsToMapPoints(path);
                prism = new BMapGL.Prism(pathPoints, altitude, {
                    topFillColor,
                    topFillOpacity,
                    sideFillColor,
                    sideFillOpacity,
                    enableMassClear
                });
                visible && map.addOverlay(prism);
                bindEvents(props, vueEmits, prism);
                ready(map, prism);
                syncMapCenter();
                watch(() => props.enableMassClear, setMassClear);
                watch(() => props.topFillColor, setTopFillColor);
                watch(() => props.topFillOpacity, setTopFillOpacity);
                watch(() => props.sideFillColor, setSideFillColor);
                watch(() => props.sideFillOpacity, setSideFillOpacity);
                watch(() => props.altitude, setAltitude);
            };
            init();
            // 监听值变化, 初始为空时不会初始化, 不为空值时初始化
            watch(() => props.path, callWhenDifferentValue((n) => {
                prism ? setPath(n) : init();
            }), {
                deep: true
            });
            watch(() => props.visible, (n) => {
                map[n ? 'addOverlay' : 'removeOverlay'](prism);
            });
            return clear;
        });
        provide('getOverlayInstance', () => prism);
        function syncMapCenter() {
            if (props.autoCenter) {
                nextTick(() => {
                    var _a;
                    // 自动设置中心点
                    // 获取中心点
                    try {
                        const center = (_a = prism.getBounds()) === null || _a === void 0 ? void 0 : _a.getCenter();
                        injectBaseMapSetCenterAndZoom(center);
                    }
                    catch (e) {
                        warn('BPrism', 'auto set center error');
                    }
                });
            }
        }
        function setMassClear(enableMassClear) {
            enableMassClear ? prism.enableMassClear() : prism.disableMassClear();
        }
        function setPath(path) {
            const { isBoundary } = props;
            prism.setPath(isBoundary ? path : pathPointsToMapPoints(path));
        }
        function setTopFillColor(color) {
            prism && prism.setTopFillColor(color);
        }
        function setTopFillOpacity(opacity) {
            prism && prism.setTopFillOpacity(opacity);
        }
        function setSideFillColor(color) {
            prism && prism.setSideFillColor(color);
        }
        function setSideFillOpacity(opacity) {
            prism && prism.setSideFillOpacity(opacity);
        }
        function setAltitude(altitude) {
            prism && prism.setAltitude(altitude);
        }
        return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
        };
    } }));

var script$4 = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BGroundOverlay'
}, { __name: 'index', props: {
        type: {},
        url: {},
        startPoint: {},
        endPoint: {},
        autoCenter: { type: Boolean, default: false },
        opacity: { default: 1 },
        visible: { type: Boolean, default: true },
        onClick: {},
        onDblclick: {},
        onMousemove: {},
        onMouseover: {},
        onMouseout: {}
    }, emits: ['initd', 'unload', 'click', 'dblclick', 'mousemove', 'mouseover', 'mouseout'], setup(__props, { emit: vueEmits }) {
        const props = __props;
        let groundOverlay;
        const { ready } = useParentComponentEffect((map) => {
            const clear = () => {
                groundOverlay && map.removeOverlay(groundOverlay);
            };
            const init = () => {
                clear();
                let { startPoint, endPoint, opacity, type, autoCenter, visible } = props;
                const url = getUrl();
                if (!url)
                    return;
                if (!startPoint) {
                    return process.env.NODE_ENV !== 'production' && warn('GroundOverlay', `startPoint is required`);
                }
                if (!endPoint)
                    return process.env.NODE_ENV !== 'production' && warn('GroundOverlay', `endPoint is required`);
                const boundsObj = getBounds(startPoint, endPoint);
                const options = {
                    opacity,
                    type,
                    url: url.value || url
                };
                groundOverlay = new BMapGL.GroundOverlay(boundsObj, options);
                visible && map.addOverlay(groundOverlay);
                // 自动设置中心点
                if (autoCenter) {
                    nextTick(() => {
                        // 获取中心点
                        try {
                            const center = boundsObj.getCenter();
                            map.panTo(center);
                        }
                        catch (e) {
                            warn('GroundOverlay', 'auto set center error');
                        }
                    });
                }
            };
            init();
            bindEvents(props, vueEmits, groundOverlay);
            ready(map, groundOverlay);
            watch(() => props, callWhenDifferentValue(init), { deep: true });
            watch(() => props.visible, (n) => {
                map[n ? 'addOverlay' : 'removeOverlay'](groundOverlay);
            });
            return clear;
        });
        provide('getOverlayInstance', () => groundOverlay);
        function getBounds(start, end) {
            return new BMapGL.Bounds(new BMapGL.Point(start.lng, end.lat), new BMapGL.Point(end.lng, start.lat));
        }
        function getUrl() {
            let url = props.url;
            if (typeof url === 'function') {
                url = url();
                if (!url) {
                    return (process.env.NODE_ENV !== 'production' &&
                        warn('GroundOverlay', `props url expect a function return string or canvas html element, but got ${url}`));
                }
            }
            return url;
        }
        return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
        };
    } }));

var script$3 = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BContextMenu',
    inheritAttrs: false
}, { __name: 'index', props: {
        width: { default: 100 },
        visible: { type: Boolean, default: true },
        menuItems: { default: () => [] },
        onOpen: {},
        onClose: {}
    }, emits: ['initd', 'unload', 'open', 'close'], setup(__props, { emit: vueEmits }) {
        const props = __props;
        const getParentInstance = inject('getOverlayInstance', () => null);
        let contextMenu;
        const { ready } = useParentComponentEffect((map) => {
            const target = getParentInstance() || map;
            const cal = () => {
                contextMenu && target.removeContextMenu(contextMenu);
            };
            const init = () => {
                const { width, menuItems, visible } = props;
                contextMenu = new BMapGL.ContextMenu();
                for (const item of menuItems) {
                    if (isString(item) && item === '-') {
                        contextMenu.addSeparator();
                        continue;
                    }
                    const menuItem = new BMapGL.MenuItem(item.text, function (point, pixel) {
                        item.callback.call(null, {
                            point,
                            pixel,
                            map,
                            BMapGL,
                            target: target
                        });
                    }, {
                        width,
                        id: String(Math.random())
                    });
                    item.disabled ? menuItem.disable() : menuItem.enable();
                    contextMenu.addItem(menuItem);
                }
                visible && target.addContextMenu(contextMenu);
                bindEvents(props, vueEmits, contextMenu);
            };
            watch(() => props.visible, (n) => {
                if (contextMenu) {
                    target[n ? 'addContextMenu' : 'removeContextMenu'](contextMenu);
                }
            });
            watch(() => {
                return props.menuItems;
            }, callWhenDifferentValue(() => {
                cal();
                init();
            }), {
                deep: true
            });
            init();
            ready(map, contextMenu);
            // 在地图上添加点标记
            return cal;
        });
        return (_ctx, _cache) => {
            return null;
        };
    } }));

var script$2 = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BDistrictLayer'
}, { __name: 'index', props: {
        visible: { type: Boolean, default: true },
        name: {},
        kind: { default: 0 },
        fillColor: { default: '#fdfd27' },
        fillOpacity: { default: 1 },
        strokeColor: { default: '#231cf8' },
        viewport: { type: Boolean, default: false },
        onClick: {},
        onDblclick: {},
        onRightclick: {},
        onRightdblclick: {},
        onMousemove: {},
        onMouseover: {},
        onMouseout: {}
    }, emits: ['initd', 'unload', 'mouseover', 'mouseout', 'click'], setup(__props, { emit: vueEmits }) {
        const props = __props;
        let districtLayer;
        const { ready } = useParentComponentEffect((map) => {
            if (!props.name)
                return error('BDistrictLayer', 'DistrictLayer props.name is required');
            const { visible, name, kind, fillColor, fillOpacity, strokeColor, viewport } = props;
            districtLayer = new BMapGL.DistrictLayer({
                name: `(${name})`,
                kind,
                fillColor,
                fillOpacity,
                strokeColor,
                viewport
            });
            visible && map.addDistrictLayer(districtLayer);
            bindEvents(props, vueEmits, districtLayer);
            watch(() => props.visible, (n) => {
                if (districtLayer) {
                    map[n ? 'addDistrictLayer' : 'removeDistrictLayer'](districtLayer);
                }
            });
            const readyTimeout = setTimeout(() => {
                ready(map, districtLayer);
            }, 400);
            return () => {
                clearTimeout(readyTimeout);
                map.removeDistrictLayer(districtLayer);
            };
        });
        return (_ctx, _cache) => {
            return null;
        };
    } }));

var script$1 = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BMapMask'
}, { __name: 'index', props: {
        path: {},
        showRegion: { default: 'inside' },
        isBuildingMask: { type: Boolean, default: false },
        isMapMask: { type: Boolean, default: false },
        isPoiMask: { type: Boolean, default: false },
        visible: { type: Boolean, default: true },
        onClick: {},
        onDblclick: {},
        onMousedown: {},
        onMouseup: {},
        onMouseout: {},
        onMouseover: {},
        onRightclick: {}
    }, emits: [
        'initd',
        'unload',
        'click',
        'dblclick',
        'mousedown',
        'mouseup',
        'mouseout',
        'mouseover',
        'rightclick'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        let mapMask;
        const { ready } = useParentComponentEffect((map) => {
            const clear = () => {
                mapMask && map.removeOverlay(mapMask);
            };
            const init = () => {
                clear();
                if (!props.path || !(props.path && props.path.length))
                    return process.env.NODE_ENV !== 'production' && warn('BMapMask', 'path is required');
                const { path, showRegion, isBuildingMask, isMapMask, isPoiMask, visible } = props;
                const pathPoints = pathPointsToMapPoints(path);
                mapMask = new BMapGL.MapMask(pathPoints, {
                    showRegion,
                    isBuildingMask,
                    isMapMask,
                    isPoiMask
                });
                visible && map.addOverlay(mapMask);
                bindEvents(props, vueEmits, mapMask);
                ready(map, mapMask);
            };
            watchPostEffect(init);
            return clear;
        });
        provide('getOverlayInstance', () => mapMask);
        return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
        };
    } }));

var script = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BAutoComplete'
}, { __name: 'index', props: {
        location: {},
        types: {},
        onSearchComplete: {},
        onHighlight: {},
        onConfirm: {}
    }, emits: ['initd', 'unload', 'searchComplete', 'highlight', 'confirm'], setup(__props, { emit: vueEmits }) {
        const props = __props;
        const autoCompleteInput = ref();
        let autoComplete;
        const { ready } = useParentComponentEffect((map) => {
            if (!autoCompleteInput.value)
                warn('BAutoComplete', 'render error');
            const { location, types } = props;
            let _location = map;
            if (typeof location === 'object' && location.lat && location.lng) {
                _location = getPoint$1(location);
            }
            autoComplete = new BMapGL.Autocomplete({
                location: _location,
                onSearchComplete: (e) => vueEmits('searchComplete', e),
                input: autoCompleteInput.value,
                types
            });
            bindEvents(props, vueEmits, autoComplete);
            ready(map, autoComplete);
            watch(() => props.location, (n) => {
                let _location = map;
                if (typeof n === 'object' && n.lat && n.lng) {
                    _location = getPoint$1(n);
                }
                autoComplete.setLocation(_location);
            });
            watch(() => props.types, (n) => {
                n && autoComplete.setTypes(n);
            });
        });
        return (_ctx, _cache) => {
            return (openBlock(), createElementBlock("input", {
                class: "b-auto-complete-input",
                type: "text",
                ref_key: "autoCompleteInput",
                ref: autoCompleteInput,
                placeholder: "请输入搜索关键词"
            }, null, 512));
        };
    } }));

var componentsList = [
    script$n,
    script$m,
    script$l,
    script$k,
    script$g,
    script$d,
    script$c,
    script$h,
    script$i,
    script$b,
    script$a,
    script$8,
    script$1,
    script$9,
    script$6,
    script$j,
    script$5,
    script$7,
    script$3,
    script$f,
    script$e,
    script$4,
    script$2,
    script
];

// global register
const vue3BaiduMapGl = {
    install: (app, options) => {
        const { ak, apiUrl, plugins: p, pluginsSourceLink: psl } = options || {};
        const appProp = app.config.globalProperties;
        for (const component of componentsList) {
            const name = component.name;
            app.component(name, component);
        }
        ak && (appProp.$baiduMapAk = ak);
        apiUrl && (appProp.$baiduMapApiUrl = apiUrl);
        p && (appProp.$baiduMapPlugins = p);
        psl && (appProp.$baiduMapPluginsSourceLink = psl);
    },
    version: '2.3.2'
};
// for umd
const install = vue3BaiduMapGl.install;
const version = vue3BaiduMapGl.version;

export { script as BAutoComplete, script$9 as BBezierCurve, script$6 as BCircle, script$j as BCityList, script$3 as BContextMenu, script$m as BControl, script$h as BCopyright, script$2 as BDistrictLayer, script$4 as BGroundOverlay, script$7 as BInfoWindow, script$b as BLabel, script$i as BLocation, script$n as BMap, script$1 as BMapMask, script$d as BMarker, script$c as BMarker3d, script$g as BNavigation3d, script$f as BPanoramaControl, script$e as BPanoramaCoverageLayer, script$8 as BPolygon, script$a as BPolyline, script$5 as BPrism, script$l as BScale, script$k as BZoom, CoordinatesFromType, CoordinatesToType, DistrictType, vue3BaiduMapGl as default, install, useAddressGeocoder, useAreaBoundary, useBrowserLocation, useDefaultMarkerIcons, useInstanceId, useIpLocation, usePoint, usePointConvertor, usePointGeocoder, useTrackAnimation, useViewAnimation, version };
