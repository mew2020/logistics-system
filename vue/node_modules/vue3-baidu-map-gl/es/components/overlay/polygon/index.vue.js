import { defineComponent, inject, watch, provide, renderSlot, nextTick } from 'vue';
import useParentComponentEffect from '../../../hooks/useParentComponentEffect';
import { callWhenDifferentValue, warn, pathPointsToMapPoints, bindEvents } from '../../../utils';

var script = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BPolygon'
}, { __name: 'index', props: {
        path: { type: Array, required: true },
        isBoundary: { type: Boolean, required: false },
        strokeColor: { type: String, required: false, default: '#000' },
        autoCenter: { type: Boolean, required: false, default: true },
        strokeWeight: { type: Number, required: false, default: 2 },
        strokeOpacity: { type: Number, required: false, default: 1 },
        strokeStyle: { type: null, required: false, default: 'solid' },
        fillColor: { type: String, required: false, default: '#fff' },
        fillOpacity: { type: Number, required: false, default: 0.3 },
        enableMassClear: { type: Boolean, required: false },
        enableEditing: { type: Boolean, required: false },
        enableClicking: { type: Boolean, required: false },
        geodesic: { type: Boolean, required: false, default: false },
        clip: { type: Boolean, required: false, default: true },
        visible: { type: Boolean, required: false, default: true },
        onClick: { type: null, required: false },
        onDblclick: { type: null, required: false },
        onMousedown: { type: null, required: false },
        onMouseup: { type: null, required: false },
        onMouseout: { type: null, required: false },
        onMouseover: { type: null, required: false },
        onRemove: { type: null, required: false },
        onLineupdate: { type: null, required: false }
    }, emits: [
        'initd',
        'unload',
        'click',
        'dblclick',
        'mousedown',
        'mouseup',
        'mouseout',
        'mouseover',
        'remove',
        'lineupdate'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        const injectBaseMapSetCenterAndZoom = inject('baseMapSetCenterAndZoom');
        let polygon;
        const { ready } = useParentComponentEffect((map) => {
            const cal = () => {
                polygon && map.removeOverlay(polygon);
            };
            const init = () => {
                if (!props.path)
                    return process.env.NODE_ENV !== 'production' && warn('BPolygon', 'path is required');
                if (!props.path.length)
                    return;
                const { path, strokeColor, strokeWeight, strokeOpacity, strokeStyle, fillOpacity, fillColor, enableMassClear, enableEditing, enableClicking, geodesic, clip, isBoundary, visible } = props;
                const pathPoints = isBoundary ? path : pathPointsToMapPoints(path);
                if (!pathPoints)
                    return;
                polygon = new BMapGL.Polygon(pathPoints, {
                    strokeColor,
                    strokeWeight,
                    strokeOpacity,
                    strokeStyle,
                    fillOpacity,
                    fillColor,
                    enableMassClear,
                    enableEditing,
                    enableClicking,
                    geodesic,
                    clip
                });
                visible && map.addOverlay(polygon);
                visible && syncMapCenter();
                bindEvents(props, vueEmits, polygon);
                ready(map, polygon);
                // 监听值变化, 初始为空时不会初始化, 不为空值时初始化
                watch(() => props.strokeColor, setStrokeColor);
                watch(() => props.strokeOpacity, setStrokeOpacity);
                watch(() => props.fillColor, setFillColor);
                watch(() => props.fillOpacity, setFillOpacity);
                watch(() => props.strokeWeight, setStrokeWeight);
                watch(() => props.strokeStyle, setStrokeStyle);
                watch(() => props.enableMassClear, setMassClear);
                watch(() => props.enableEditing, setEditing);
                watch(() => props.visible, (n) => {
                    map[n ? 'addOverlay' : 'removeOverlay'](polygon);
                    n && syncMapCenter();
                });
            };
            init();
            watch(() => props.path, callWhenDifferentValue((path) => {
                polygon ? setPath(path) : init();
            }), {
                deep: true
            });
            return cal;
        });
        provide('getOverlayInstance', () => polygon);
        function syncMapCenter() {
            nextTick(() => {
                // 自动设置中心点
                if (props.autoCenter) {
                    // 获取中心点
                    try {
                        const bounds = polygon.getBounds();
                        if (bounds) {
                            const center = bounds.getCenter();
                            center && injectBaseMapSetCenterAndZoom(center);
                        }
                    }
                    catch (e) {
                        console.warn('BPolygon', 'auto set center error', e);
                    }
                }
            });
        }
        function setPath(path) {
            const { isBoundary } = props;
            polygon.setPath(isBoundary ? path : pathPointsToMapPoints(path));
            syncMapCenter();
        }
        function setStrokeColor(color) {
            polygon && polygon.setStrokeColor(color);
        }
        function setFillColor(color) {
            polygon && polygon.setFillColor(color);
        }
        function setStrokeOpacity(opacity) {
            polygon && polygon.setStrokeOpacity(opacity);
        }
        function setFillOpacity(opacity) {
            polygon && polygon.setFillOpacity(opacity);
        }
        function setStrokeWeight(weight) {
            polygon && polygon.setStrokeWeight(weight);
        }
        function setStrokeStyle(style) {
            polygon && polygon.setStrokeStyle(style);
        }
        function setMassClear(enableMassClear) {
            if (polygon)
                enableMassClear ? polygon.enableMassClear() : polygon.disableMassClear();
        }
        function setEditing(enableEditing) {
            if (polygon)
                enableEditing ? polygon.enableEditing() : polygon.disableEditing();
        }
        return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
        };
    } }));

script.__file = "packages/components/overlay/polygon/index.vue";

export { script as default };
