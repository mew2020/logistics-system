import { defineComponent, watch, provide, renderSlot, nextTick } from 'vue';
import useParentComponentEffect from '../../../hooks/useParentComponentEffect';
import { bindEvents, callWhenDifferentValue, warn } from '../../../utils';

var script = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BGroundOverlay'
}, { __name: 'index', props: {
        type: { type: String, required: true },
        url: { type: [String, Function], required: true, skipCheck: true },
        startPoint: { type: null, required: true },
        endPoint: { type: null, required: true },
        autoCenter: { type: Boolean, required: false, default: false },
        opacity: { type: Number, required: false, default: 1 },
        visible: { type: Boolean, required: false, default: true },
        onClick: { type: null, required: false },
        onDblclick: { type: null, required: false },
        onMousemove: { type: null, required: false },
        onMouseover: { type: null, required: false },
        onMouseout: { type: null, required: false }
    }, emits: ['initd', 'unload', 'click', 'dblclick', 'mousemove', 'mouseover', 'mouseout'], setup(__props, { emit: vueEmits }) {
        const props = __props;
        let groundOverlay;
        const { ready } = useParentComponentEffect((map) => {
            const clear = () => {
                groundOverlay && map.removeOverlay(groundOverlay);
            };
            const init = () => {
                clear();
                let { startPoint, endPoint, opacity, type, autoCenter, visible } = props;
                const url = getUrl();
                if (!url)
                    return;
                if (!startPoint) {
                    return process.env.NODE_ENV !== 'production' && warn('GroundOverlay', `startPoint is required`);
                }
                if (!endPoint)
                    return process.env.NODE_ENV !== 'production' && warn('GroundOverlay', `endPoint is required`);
                const boundsObj = getBounds(startPoint, endPoint);
                const options = {
                    opacity,
                    type,
                    url: url.value || url
                };
                groundOverlay = new BMapGL.GroundOverlay(boundsObj, options);
                visible && map.addOverlay(groundOverlay);
                // 自动设置中心点
                if (autoCenter) {
                    nextTick(() => {
                        // 获取中心点
                        try {
                            const center = boundsObj.getCenter();
                            map.panTo(center);
                        }
                        catch (e) {
                            warn('GroundOverlay', 'auto set center error');
                        }
                    });
                }
            };
            init();
            bindEvents(props, vueEmits, groundOverlay);
            ready(map, groundOverlay);
            watch(() => props, callWhenDifferentValue(init), { deep: true });
            watch(() => props.visible, (n) => {
                map[n ? 'addOverlay' : 'removeOverlay'](groundOverlay);
            });
            return clear;
        });
        provide('getOverlayInstance', () => groundOverlay);
        function getBounds(start, end) {
            return new BMapGL.Bounds(new BMapGL.Point(start.lng, end.lat), new BMapGL.Point(end.lng, start.lat));
        }
        function getUrl() {
            let url = props.url;
            if (typeof url === 'function') {
                url = url();
                if (!url) {
                    return (process.env.NODE_ENV !== 'production' &&
                        warn('GroundOverlay', `props url expect a function return string or canvas html element, but got ${url}`));
                }
            }
            return url;
        }
        return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
        };
    } }));

script.__file = "packages/components/overlay/ground-overlay/index.vue";

export { script as default };
