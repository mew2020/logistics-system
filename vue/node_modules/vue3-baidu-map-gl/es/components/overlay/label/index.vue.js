import { defineComponent, watch, provide, renderSlot } from 'vue';
import useParentComponentEffect from '../../../hooks/useParentComponentEffect';
import { callWhenDifferentValue, conditionalCall, warn, isDef, bindEvents } from '../../../utils';

var script = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BLabel'
}, { __name: 'index', props: {
        content: { type: String, required: true },
        position: { type: null, required: true },
        offset: { type: Object, required: false, default: () => ({
                x: 0,
                y: 0
            }) },
        zIndex: { type: Number, required: false },
        style: { type: null, required: false },
        enableMassClear: { type: Boolean, required: false, default: true },
        visible: { type: Boolean, required: false, default: true },
        onClick: { type: null, required: false },
        onDblclick: { type: null, required: false },
        onMousedown: { type: null, required: false },
        onMouseup: { type: null, required: false },
        onMouseout: { type: null, required: false },
        onMouseover: { type: null, required: false },
        onRemove: { type: null, required: false },
        onRightclick: { type: null, required: false }
    }, emits: [
        'initd',
        'unload',
        'click',
        'dblclick',
        'mousedown',
        'mouseup',
        'mouseout',
        'mouseover',
        'remove',
        'rightclick'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        let label;
        const hasLabel = () => !!label;
        const { ready } = useParentComponentEffect((map) => {
            const cal = () => {
                label && map.removeOverlay(label);
            };
            const init = () => {
                if (!props.content)
                    return process.env.NODE_ENV !== 'production' && warn('BLabel', 'content is required');
                if (!props.position)
                    return process.env.NODE_ENV !== 'production' && warn('BLabel', 'position is required');
                const { content, position, offset, enableMassClear, style, visible, zIndex } = props;
                const options = {
                    position: new BMapGL.Point(position.lng, position.lat),
                    offset: new BMapGL.Size(offset.x, offset.y),
                    enableMassClear
                };
                label = new BMapGL.Label(content, options);
                // 自定义文本标注样式
                if (style) {
                    label.setStyle(style);
                }
                visible && map.addOverlay(label);
                isDef(zIndex) && setZIndex(zIndex);
                bindEvents(props, vueEmits, label);
                watch(() => props.offset, callWhenDifferentValue(setOffset), { deep: true });
                watch(() => props.style, callWhenDifferentValue(setStyle), { deep: true });
                watch(() => props.enableMassClear, setMassClear);
                watch(() => props.zIndex, setZIndex);
                watch(() => props.visible, (n) => {
                    map[n ? 'addOverlay' : 'removeOverlay'](label);
                });
            };
            init();
            ready(map, label);
            // 监听值变化
            watch(() => props.position, callWhenDifferentValue(conditionalCall(hasLabel, setPosition, init)), { deep: true });
            watch(() => props.content, conditionalCall(hasLabel, setContent, init));
            return cal;
        });
        provide('getOverlayInstance', () => label);
        function setZIndex(zIndex) {
            isDef(zIndex) && label.setZIndex(zIndex);
        }
        function setPosition(position) {
            label.setPosition(new BMapGL.Point(position.lng, position.lat));
        }
        function setStyle(styles) {
            if (isDef(styles))
                label.setStyle(styles);
        }
        function setContent(content) {
            label.setContent(content);
        }
        function setOffset(offset) {
            label.setOffset(new BMapGL.Size(offset.x, offset.y));
        }
        function setMassClear(enableMassClear) {
            enableMassClear ? label.enableMassClear() : label.disableMassClear();
        }
        return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
        };
    } }));

script.__file = "packages/components/overlay/label/index.vue";

export { script as default };
