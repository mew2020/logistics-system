import { defineComponent, computed, ref, watchEffect, nextTick, watch, onUpdated, provide, openBlock, createElementBlock, createElementVNode, mergeProps, renderSlot } from 'vue';
import useParentComponentEffect from '../../../hooks/useParentComponentEffect';
import { warnOnce, callWhenDifferentValue, bindEvents } from '../../../utils';

const _hoisted_1 = { style: { "display": "none" } };
var script = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BInfoWindow'
}, { __name: 'index', props: {
        modelValue: { type: Boolean, required: false, default: undefined },
        show: { type: Boolean, required: false, default: false },
        title: { type: String, required: false, default: '' },
        position: { type: null, required: true },
        width: { type: null, required: false, default: 0 },
        height: { type: null, required: false, default: 0 },
        maxWidth: { type: null, required: false, default: 220 },
        offset: { type: Object, required: false, default: () => ({
                x: 0,
                y: 0
            }) },
        enableAutoPan: { type: Boolean, required: false, default: true },
        enableCloseOnClick: { type: Boolean, required: false, default: true },
        onClose: { type: null, required: false },
        onOpen: { type: null, required: false },
        onMaximize: { type: null, required: false },
        onRestore: { type: null, required: false },
        onClickclose: { type: null, required: false }
    }, emits: ['initd', 'unload', 'close', 'open', 'maximize', 'restore', 'clickclose', 'update:show'], setup(__props, { emit: vueEmits }) {
        const props = __props;
        const visible = computed({
            get: () => props.show,
            set: (value) => vueEmits('update:show', value)
        });
        const infoWindowContainer = ref();
        let infoWindow;
        let _map;
        watchEffect(() => {
            if (typeof props.modelValue !== 'undefined' && process.env.NODE_ENV !== 'production') {
                warnOnce('BInfoWindow', '`v-model` is deprecated, please use `v-model:show` instead.');
            }
        });
        const { ready } = useParentComponentEffect((map) => {
            _map = map;
            const clear = () => {
                infoWindow && map.removeOverlay(infoWindow);
            };
            const init = () => {
                const { title, width, height, enableAutoPan, maxWidth, offset, enableCloseOnClick } = props;
                const options = {
                    width,
                    height,
                    title,
                    maxWidth,
                    enableAutoPan,
                    enableCloseOnClick,
                    offset: new BMapGL.Size(offset.x, offset.y)
                };
                infoWindow = new BMapGL.InfoWindow(infoWindowContainer.value || '', options);
                infoWindow.addEventListener('close', () => {
                    if (props.show)
                        visible.value = false;
                });
                infoWindow.addEventListener('open', () => {
                    if (!props.show)
                        visible.value = true;
                });
                map.addOverlay(infoWindow);
                redraw();
                bindObserver();
                bindEvents(props, vueEmits, infoWindow);
                ready(map, infoWindow);
                if (props.show) {
                    // 多个 infoWindow, 显示最后一个实例, 其他实例同步显隐状态
                    nextTick(() => {
                        open();
                        nextTick(() => {
                            !infoWindow._visible && (visible.value = false);
                        });
                    });
                }
            };
            if (!infoWindowContainer.value) {
                nextTick(() => init());
            }
            else {
                init();
            }
            // 监听值变化
            watch(() => props.position, callWhenDifferentValue((position) => setPosition(position)), { deep: true });
            watch(() => props.title, setTitle);
            watch(() => props.width, setWidth);
            watch(() => props.height, setHeight);
            watch(() => props.maxWidth, setMaxWidth);
            watch(() => props.enableAutoPan, setAutoPan);
            watch(() => props.enableCloseOnClick, setCloseOnClick);
            watch(() => props.show, callWhenDifferentValue(() => {
                props.show ? open() : close();
            }));
            return clear;
        });
        onUpdated(() => {
            if (infoWindow && infoWindow.isOpen()) {
                setContent(infoWindowContainer.value || '');
                redraw();
            }
        });
        provide('getOverlayInstance', () => infoWindow);
        function bindObserver() {
            const MutationObserver = window.MutationObserver;
            if (!MutationObserver) {
                return;
            }
            new MutationObserver(() => {
                infoWindow.redraw();
            }).observe(infoWindowContainer.value, { attributes: true, childList: true, characterData: true, subtree: true });
        }
        function open() {
            const { position } = props;
            if (!position || !infoWindow)
                return;
            _map.openInfoWindow(infoWindow, new BMapGL.Point(position.lng, position.lat));
            visible.value = true;
        }
        function close() {
            if (!infoWindow)
                return;
            infoWindow.hide();
            visible.value = false;
        }
        function redraw() {
            var _a;
            infoWindow.redraw();
            Array.prototype.forEach.call(((_a = infoWindowContainer.value) === null || _a === void 0 ? void 0 : _a.querySelectorAll('img')) || [], (imgEl) => {
                imgEl.onload = () => {
                    infoWindow.redraw();
                };
            });
        }
        function setTitle(title) {
            infoWindow.setTitle(title);
        }
        function setHeight(height) {
            infoWindow.setHeight(height);
        }
        function setWidth(width) {
            infoWindow.setWidth(width);
        }
        function setMaxWidth(maxWidth) {
            infoWindow.setMaxWidth(maxWidth);
        }
        // function setMaximize(maximize: boolean) {
        // 	maximize ? infoWindow.enableMaximize() : infoWindow.disableMaximize()
        // }
        function setAutoPan(autoPan) {
            autoPan ? infoWindow.enableAutoPan() : infoWindow.disableAutoPan();
        }
        function setCloseOnClick(closeOnClick) {
            closeOnClick ? infoWindow.enableCloseOnClick() : infoWindow.disableCloseOnClick();
        }
        function setPosition(position) {
            open();
            infoWindow.setPosition(new BMapGL.Point(position.lng, position.lat));
            if (!visible.value)
                close();
        }
        function setContent(content) {
            infoWindow.setContent(content);
        }
        return (_ctx, _cache) => {
            return (openBlock(), createElementBlock("div", _hoisted_1, [
                createElementVNode("div", mergeProps({
                    ref_key: "infoWindowContainer",
                    ref: infoWindowContainer
                }, _ctx.$attrs), [
                    renderSlot(_ctx.$slots, "default")
                ], 16 /* FULL_PROPS */)
            ]));
        };
    } }));

script.__file = "packages/components/overlay/infowindow/index.vue";

export { script as default };
