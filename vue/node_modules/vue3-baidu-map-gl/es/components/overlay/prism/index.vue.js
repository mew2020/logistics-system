import { defineComponent, inject, watch, provide, renderSlot, nextTick } from 'vue';
import useParentComponentEffect from '../../../hooks/useParentComponentEffect';
import { callWhenDifferentValue, warn, pathPointsToMapPoints, bindEvents } from '../../../utils';

var script = /*#__PURE__*/ defineComponent(Object.assign({
    name: 'BPrism'
}, { __name: 'index', props: {
        path: { type: Array, required: true },
        altitude: { type: Number, required: true },
        isBoundary: { type: Boolean, required: false },
        topFillColor: { type: String, required: false, default: '#fff' },
        topFillOpacity: { type: Number, required: false, default: 0.5 },
        sideFillColor: { type: String, required: false, default: '#fff' },
        sideFillOpacity: { type: Number, required: false, default: 0.8 },
        autoCenter: { type: Boolean, required: false, default: true },
        enableMassClear: { type: Boolean, required: false, default: true },
        visible: { type: Boolean, required: false, default: true },
        onClick: { type: null, required: false },
        onDblclick: { type: null, required: false },
        onMousedown: { type: null, required: false },
        onMouseup: { type: null, required: false },
        onMouseout: { type: null, required: false },
        onMouseover: { type: null, required: false },
        onRemove: { type: null, required: false },
        onLineupdate: { type: null, required: false }
    }, emits: [
        'initd',
        'unload',
        'click',
        'dblclick',
        'mousedown',
        'mouseup',
        'mouseout',
        'mouseover',
        'remove',
        'lineupdate'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        const injectBaseMapSetCenterAndZoom = inject('baseMapSetCenterAndZoom');
        let prism;
        const { ready } = useParentComponentEffect((map) => {
            const clear = () => {
                prism && map.removeOverlay(prism);
            };
            const init = () => {
                if (!props.path || !(props.path && props.path.length))
                    return process.env.NODE_ENV !== 'production' && warn('BPrism', 'path is required');
                const { path, altitude, isBoundary, topFillColor, topFillOpacity, sideFillColor, sideFillOpacity, enableMassClear, visible } = props;
                const pathPoints = isBoundary ? path : pathPointsToMapPoints(path);
                prism = new BMapGL.Prism(pathPoints, altitude, {
                    topFillColor,
                    topFillOpacity,
                    sideFillColor,
                    sideFillOpacity,
                    enableMassClear
                });
                visible && map.addOverlay(prism);
                bindEvents(props, vueEmits, prism);
                ready(map, prism);
                syncMapCenter();
                watch(() => props.enableMassClear, setMassClear);
                watch(() => props.topFillColor, setTopFillColor);
                watch(() => props.topFillOpacity, setTopFillOpacity);
                watch(() => props.sideFillColor, setSideFillColor);
                watch(() => props.sideFillOpacity, setSideFillOpacity);
                watch(() => props.altitude, setAltitude);
            };
            init();
            // 监听值变化, 初始为空时不会初始化, 不为空值时初始化
            watch(() => props.path, callWhenDifferentValue((n) => {
                prism ? setPath(n) : init();
            }), {
                deep: true
            });
            watch(() => props.visible, (n) => {
                map[n ? 'addOverlay' : 'removeOverlay'](prism);
            });
            return clear;
        });
        provide('getOverlayInstance', () => prism);
        function syncMapCenter() {
            if (props.autoCenter) {
                nextTick(() => {
                    var _a;
                    // 自动设置中心点
                    // 获取中心点
                    try {
                        const center = (_a = prism.getBounds()) === null || _a === void 0 ? void 0 : _a.getCenter();
                        injectBaseMapSetCenterAndZoom(center);
                    }
                    catch (e) {
                        warn('BPrism', 'auto set center error');
                    }
                });
            }
        }
        function setMassClear(enableMassClear) {
            enableMassClear ? prism.enableMassClear() : prism.disableMassClear();
        }
        function setPath(path) {
            const { isBoundary } = props;
            prism.setPath(isBoundary ? path : pathPointsToMapPoints(path));
        }
        function setTopFillColor(color) {
            prism && prism.setTopFillColor(color);
        }
        function setTopFillOpacity(opacity) {
            prism && prism.setTopFillOpacity(opacity);
        }
        function setSideFillColor(color) {
            prism && prism.setSideFillColor(color);
        }
        function setSideFillOpacity(opacity) {
            prism && prism.setSideFillOpacity(opacity);
        }
        function setAltitude(altitude) {
            prism && prism.setAltitude(altitude);
        }
        return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
        };
    } }));

script.__file = "packages/components/overlay/prism/index.vue";

export { script as default };
