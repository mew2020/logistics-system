import { defineComponent, watch, provide, renderSlot } from 'vue';
import useParentComponentEffect from '../../../hooks/useParentComponentEffect';
import { callWhenDifferentValue, warn, pathPointsToMapPoints, error, bindEvents } from '../../../utils';

var script = /*#__PURE__*/ defineComponent(Object.assign({ name: 'BBezierCurve' }, { __name: 'index', props: {
        path: { type: Array, required: true },
        controlPoints: { type: Array, required: true },
        strokeColor: { type: String, required: false, default: '#000' },
        strokeWeight: { type: Number, required: false, default: 2 },
        strokeOpacity: { type: Number, required: false, default: 1 },
        strokeStyle: { type: null, required: false, default: 'solid' },
        enableMassClear: { type: Boolean, required: false, default: true },
        visible: { type: Boolean, required: false, default: true },
        onClick: { type: null, required: false },
        onDblclick: { type: null, required: false },
        onMousedown: { type: null, required: false },
        onMouseup: { type: null, required: false },
        onMouseout: { type: null, required: false },
        onMouseover: { type: null, required: false },
        onRemove: { type: null, required: false },
        onLineupdate: { type: null, required: false }
    }, emits: [
        'initd',
        'unload',
        'click',
        'dblclick',
        'mousedown',
        'mouseup',
        'mouseout',
        'mouseover',
        'remove',
        'lineupdate'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        let bezierCurve;
        const { ready } = useParentComponentEffect((map) => {
            const cal = () => {
                map.removeOverlay(bezierCurve);
            };
            const init = () => {
                if (!props.path || !(props.path && props.path.length))
                    return process.env.NODE_ENV !== 'production' && warn('BezierCurve', 'path props is required or not empty array');
                if (!props.controlPoints || !(props.controlPoints && props.controlPoints.length))
                    return process.env.NODE_ENV !== 'production' && warn('BezierCurve', 'controlPoints props is required or not empty array');
                const { path, controlPoints, strokeColor, strokeWeight, strokeOpacity, strokeStyle, enableMassClear, visible } = props;
                const pathPoints = pathPointsToMapPoints(path);
                const _controlPoints = controlPoints.map((points) => {
                    return pathPointsToMapPoints(points);
                });
                try {
                    bezierCurve = new BMapGL.BezierCurve(pathPoints, _controlPoints, {
                        strokeColor,
                        strokeWeight,
                        strokeOpacity,
                        strokeStyle,
                        enableMassClear
                    });
                }
                catch (e) {
                    if (process.env.NODE_ENV !== 'production')
                        error('BezierCurve', e.message || 'Init bezierCurve overlay error, make sure path and controlPoints data is correct!');
                }
                visible && map.addOverlay(bezierCurve);
                ready(map, bezierCurve);
                bindEvents(props, vueEmits, bezierCurve);
            };
            init();
            // 监听值变化
            watch(() => props.path, callWhenDifferentValue((n) => {
                bezierCurve ? setPath(n) : init();
            }), {
                deep: true
            });
            watch(() => props.controlPoints, callWhenDifferentValue((n) => {
                bezierCurve ? setControlPoints(n) : init();
            }), {
                deep: true
            });
            watch(() => props.strokeColor, setStrokeColor);
            watch(() => props.strokeOpacity, setStrokeOpacity);
            watch(() => props.strokeWeight, setStrokeWeight);
            watch(() => props.strokeStyle, setStrokeStyle);
            watch(() => props.enableMassClear, setMassClear);
            watch(() => props.visible, (n) => {
                map[n ? 'addOverlay' : 'removeOverlay'](bezierCurve);
            });
            return cal;
        });
        provide('getOverlayInstance', () => bezierCurve);
        function setPath(path) {
            bezierCurve.setPath(pathPointsToMapPoints(path));
        }
        function setControlPoints(points) {
            bezierCurve.setControlPoints(points.map((points) => pathPointsToMapPoints(points)));
        }
        function setStrokeColor(color) {
            bezierCurve.setStrokeColor(color);
        }
        function setStrokeOpacity(opacity) {
            bezierCurve.setStrokeOpacity(opacity);
        }
        function setStrokeWeight(weight) {
            bezierCurve.setStrokeWeight(weight);
        }
        function setStrokeStyle(style) {
            bezierCurve.setStrokeStyle(style);
        }
        function setMassClear(enableMassClear) {
            enableMassClear ? bezierCurve.enableMassClear() : bezierCurve.disableMassClear();
        }
        return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
        };
    } }));

script.__file = "packages/components/overlay/bezierCurve/index.vue";

export { script as default };
